"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultisigTransactionsFactory = void 0;
const abi_1 = require("../abi");
const core_1 = require("../core");
const transactionBuilder_1 = require("../core/transactionBuilder");
const smartContracts_1 = require("../smartContracts");
const proposeTransferExecuteContractInput_1 = require("./proposeTransferExecuteContractInput");
/**
 * Use this class to create multisig related transactions like creating a new multisig contract,
 * proposing actions, signing actions, and performing actions.
 */
class MultisigTransactionsFactory {
    constructor(options) {
        this.config = options.config;
        this.abi = options.abi;
        this.argSerializer = new abi_1.ArgSerializer();
        this.smartContractFactory = new smartContracts_1.SmartContractTransactionsFactory(options);
    }
    /**
     * Creates a transaction to deploy a new multisig contract
     */
    createTransactionForDeploy(sender, options) {
        const boardAddresses = options.board.map((addr) => new abi_1.AddressValue(addr));
        const args = [new abi_1.U32Value(options.quorum), abi_1.VariadicValue.fromItems(...boardAddresses)];
        return this.smartContractFactory.createTransactionForDeploy(sender, {
            bytecode: options.bytecode,
            gasLimit: options.gasLimit,
            isUpgradeable: options.isUpgradeable,
            isReadable: options.isReadable,
            isPayable: options.isPayable,
            isPayableBySmartContract: options.isPayableBySmartContract,
            arguments: args,
        });
    }
    /**
     * Proposes adding a new board member
     */
    createTransactionForProposeAddBoardMember(sender, options) {
        return this.smartContractFactory.createTransactionForExecute(sender, {
            contract: options.multisigContract,
            function: "proposeAddBoardMember",
            gasLimit: options.gasLimit,
            arguments: [options.boardMember],
        });
    }
    /**
     * Proposes adding a new proposer
     */
    createTransactionForProposeAddProposer(sender, options) {
        return this.smartContractFactory.createTransactionForExecute(sender, {
            contract: options.multisigContract,
            function: "proposeAddProposer",
            gasLimit: options.gasLimit,
            arguments: [options.proposer],
        });
    }
    /**
     * Proposes removing a user (board member or proposer)
     */
    createTransactionForProposeRemoveUser(sender, options) {
        return this.smartContractFactory.createTransactionForExecute(sender, {
            contract: options.multisigContract,
            function: "proposeRemoveUser",
            gasLimit: options.gasLimit,
            arguments: [options.userAddress],
        });
    }
    /**
     * Proposes changing the quorum (minimum signatures required)
     */
    createTransactionForProposeChangeQuorum(sender, options) {
        return this.smartContractFactory.createTransactionForExecute(sender, {
            contract: options.multisigContract,
            function: "proposeChangeQuorum",
            gasLimit: options.gasLimit,
            arguments: [options.newQuorum],
        });
    }
    /**
     * Proposes a transaction that will transfer EGLD and/or execute a function
     */
    createTransactionForProposeTransferExecute(sender, options) {
        const gasOption = new abi_1.U64Value(options.optGasLimit ?? 0n);
        const input = proposeTransferExecuteContractInput_1.ProposeTransferExecuteContractInput.newFromTransferExecuteInput({
            multisig: options.multisigContract,
            to: options.to,
            functionName: options.functionName,
            arguments: options.functionArguments,
            abi: options.abi,
        });
        return this.smartContractFactory.createTransactionForExecute(sender, {
            contract: options.multisigContract,
            function: "proposeTransferExecute",
            gasLimit: options.gasLimit,
            arguments: [
                new abi_1.AddressValue(options.to),
                new abi_1.BigUIntValue(options.nativeTokenAmount),
                new abi_1.OptionValue(new abi_1.OptionType(new abi_1.U64Type()), gasOption),
                abi_1.VariadicValue.fromItems(...input.functionCall.map((value) => new abi_1.BytesValue(value))),
            ],
        });
    }
    /**
     * Proposes a transaction that will transfer EGLD and/or execute a function
     */
    createTransactionForDeposit(sender, options) {
        return this.smartContractFactory.createTransactionForExecute(sender, {
            contract: options.multisigContract,
            function: "deposit",
            gasLimit: options.gasLimit,
            arguments: [],
            nativeTransferAmount: options.nativeTokenAmount,
            tokenTransfers: options.tokenTransfers,
        });
    }
    /**
     * Proposes a transaction that will transfer ESDT tokens and/or execute a function
     */
    createTransactionForProposeTransferExecuteEsdt(sender, options) {
        const input = proposeTransferExecuteContractInput_1.ProposeTransferExecuteContractInput.newFromTransferExecuteInput({
            multisig: options.multisigContract,
            to: options.to,
            functionName: options.functionName,
            arguments: options.functionArguments,
            abi: options.abi,
        });
        const tokenPayments = this.mapTokenPayments(options);
        const dataParts = [
            "proposeTransferExecuteEsdt",
            ...this.argSerializer.valuesToStrings(abi_1.NativeSerializer.nativeToTypedValues([options.to, tokenPayments, options.optGasLimit, abi_1.VariadicValue.fromItems(...input.functionCall)], this.abi.getEndpoint("proposeTransferExecuteEsdt"))),
        ];
        return new transactionBuilder_1.TransactionBuilder({
            config: this.config,
            sender: sender,
            receiver: options.multisigContract,
            dataParts: dataParts,
            gasLimit: options.gasLimit,
            addDataMovementGas: false,
        }).build();
    }
    mapTokenPayments(options) {
        const tokenComputer = new core_1.TokenComputer();
        const tokens = [];
        for (const token of options.tokens) {
            tokens.push({
                token_identifier: tokenComputer.extractIdentifierFromExtendedIdentifier(token.token.identifier),
                token_nonce: token.token.nonce,
                amount: token.amount,
            });
        }
        return tokens;
    }
    /**
     * Proposes an async call to another contract
     */
    createTransactionForProposeAsyncCall(sender, options) {
        const input = proposeTransferExecuteContractInput_1.ProposeTransferExecuteContractInput.newFromProposeAsyncCallInput({
            multisig: options.multisigContract,
            to: options.to,
            tokenTransfers: options.tokenTransfers,
            functionName: options.functionName,
            arguments: options.functionArguments,
            abi: options.abi,
        });
        return this.smartContractFactory.createTransactionForExecute(sender, {
            contract: options.multisigContract,
            function: "proposeAsyncCall",
            gasLimit: options.gasLimit,
            arguments: [
                new abi_1.AddressValue(options.to),
                new abi_1.BigUIntValue(options.nativeTransferAmount),
                new abi_1.BigUIntValue(options.optGasLimit ?? 0n),
                abi_1.VariadicValue.fromItems(...input.functionCall.map((value) => new abi_1.BytesValue(value))),
            ],
        });
    }
    /**
     * Proposes deploying a smart contract from source
     */
    createTransactionForProposeContractDeployFromSource(sender, options) {
        let args = this.argsToTypedValues(options.arguments, options.abi?.constructorDefinition);
        return this.smartContractFactory.createTransactionForExecute(sender, {
            contract: options.multisigContract,
            function: "proposeSCDeployFromSource",
            gasLimit: options.gasLimit,
            arguments: [
                new abi_1.BigUIntValue(options.amount),
                new abi_1.AddressValue(options.multisigContract),
                new abi_1.CodeMetadataValue(options.codeMetadata),
                abi_1.VariadicValue.fromItems(...args),
            ],
        });
    }
    /**
     * Proposes upgrading a smart contract from source
     */
    createTransactionForProposeContractUpgradeFromSource(sender, options) {
        let args = this.argsToTypedValues(options.arguments, options.abi?.constructorDefinition);
        return this.smartContractFactory.createTransactionForExecute(sender, {
            contract: options.multisigContract,
            function: "proposeSCUpgradeFromSource",
            gasLimit: options.gasLimit,
            arguments: [
                new abi_1.AddressValue(options.multisigContract),
                new abi_1.BigUIntValue(options.amount),
                new abi_1.AddressValue(options.source),
                new abi_1.CodeMetadataValue(options.codeMetadata),
                abi_1.VariadicValue.fromItems(...args),
            ],
        });
    }
    /**
     * Signs an action (by a board member)
     */
    createTransactionForSignAction(sender, options) {
        return this.smartContractFactory.createTransactionForExecute(sender, {
            contract: options.multisigContract,
            function: "sign",
            gasLimit: options.gasLimit,
            arguments: [options.actionId],
        });
    }
    /**
     * Signs all actions in a batch
     */
    createTransactionForSignBatch(sender, options) {
        return this.smartContractFactory.createTransactionForExecute(sender, {
            contract: options.multisigContract,
            function: "signBatch",
            gasLimit: options.gasLimit,
            arguments: [options.groupId],
        });
    }
    /**
     * Signs and performs an action in one transaction
     */
    createTransactionForSignAndPerform(sender, options) {
        return this.smartContractFactory.createTransactionForExecute(sender, {
            contract: options.multisigContract,
            function: "signAndPerform",
            gasLimit: options.gasLimit,
            arguments: [options.actionId],
        });
    }
    /**
     * Signs and performs all actions in a batch
     */
    createTransactionForSignBatchAndPerform(sender, options) {
        return this.smartContractFactory.createTransactionForExecute(sender, {
            contract: options.multisigContract,
            function: "signBatchAndPerform",
            gasLimit: options.gasLimit,
            arguments: [options.groupId],
        });
    }
    /**
     * Withdraws signature from an action
     */
    createTransactionForUnsign(sender, options) {
        return this.smartContractFactory.createTransactionForExecute(sender, {
            contract: options.multisigContract,
            function: "unsign",
            gasLimit: options.gasLimit,
            arguments: [options.actionId],
        });
    }
    /**
     * Withdraws signatures from all actions in a batch
     */
    createTransactionForUnsignBatch(sender, options) {
        return this.smartContractFactory.createTransactionForExecute(sender, {
            contract: options.multisigContract,
            function: "unsignBatch",
            gasLimit: options.gasLimit,
            arguments: [options.groupId],
        });
    }
    /**
     * Removes signatures from outdated board members
     */
    createTransactionForUnsignForOutdatedBoardMembers(sender, options) {
        const outdatedBoardMembers = options.outdatedBoardMembers.map((id) => new abi_1.U32Value(id));
        return this.smartContractFactory.createTransactionForExecute(sender, {
            contract: options.multisigContract,
            function: "unsignForOutdatedBoardMembers",
            gasLimit: options.gasLimit,
            arguments: [new abi_1.U32Value(options.actionId), abi_1.VariadicValue.fromItems(...outdatedBoardMembers)],
        });
    }
    /**
     * Performs an action that has reached quorum
     */
    createTransactionForPerformAction(sender, options) {
        return this.smartContractFactory.createTransactionForExecute(sender, {
            contract: options.multisigContract,
            function: "performAction",
            gasLimit: options.gasLimit,
            arguments: [options.actionId],
        });
    }
    /**
     * Performs all actions in a batch that have reached quorum
     */
    createTransactionForPerformBatch(sender, options) {
        return this.smartContractFactory.createTransactionForExecute(sender, {
            contract: options.multisigContract,
            function: "performBatch",
            gasLimit: options.gasLimit,
            arguments: [options.groupId],
        });
    }
    /**
     * Discards an action that is no longer needed
     */
    createTransactionForDiscardAction(sender, options) {
        return this.smartContractFactory.createTransactionForExecute(sender, {
            contract: options.multisigContract,
            function: "discardAction",
            gasLimit: options.gasLimit,
            arguments: [options.actionId],
        });
    }
    /**
     * Discards all actions in the provided list
     */
    createTransactionForDiscardBatch(sender, options) {
        const actionIdsArgs = options.actionIds.map((id) => new abi_1.U32Value(id));
        return this.smartContractFactory.createTransactionForExecute(sender, {
            contract: options.multisigContract,
            function: "discardBatch",
            gasLimit: options.gasLimit,
            arguments: [abi_1.VariadicValue.fromItems(...actionIdsArgs)],
        });
    }
    argsToTypedValues(args, endpoint) {
        if (endpoint) {
            const typedArgs = abi_1.NativeSerializer.nativeToTypedValues(args, endpoint);
            return typedArgs;
        }
        if (this.areArgsOfTypedValue(args)) {
            return args;
        }
        throw new core_1.Err("Can't convert args to TypedValues");
    }
    areArgsOfTypedValue(args) {
        return args.every((arg) => abi_1.isTyped(arg));
    }
}
exports.MultisigTransactionsFactory = MultisigTransactionsFactory;
//# sourceMappingURL=multisigTransactionsFactory.js.map