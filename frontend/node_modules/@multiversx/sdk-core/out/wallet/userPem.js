"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserPem = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const pemEntry_1 = require("./pemEntry");
const userKeys_1 = require("./userKeys");
class UserPem {
    constructor(label, secretKey) {
        this.label = label;
        this.secretKey = secretKey;
        this.publicKey = secretKey.generatePublicKey();
    }
    static fromFile(path, index = 0) {
        return this.fromFileAll(path)[index];
    }
    static fromFileAll(path) {
        const resolvedPath = path_1.isAbsolute(path.toString())
            ? path_1.resolve(path.toString())
            : path_1.resolve(path_1.join(process.cwd(), path.toString()));
        const text = fs_1.readFileSync(resolvedPath, "utf-8");
        return this.fromTextAll(text);
    }
    static fromText(text, index = 0) {
        const items = this.fromTextAll(text);
        return items[index];
    }
    static fromTextAll(text) {
        const entries = pemEntry_1.PemEntry.fromTextAll(text);
        const resultItems = [];
        for (const entry of entries) {
            const secretKey = new userKeys_1.UserSecretKey(entry.message.slice(0, userKeys_1.USER_SEED_LENGTH));
            const item = new UserPem(entry.label, secretKey);
            resultItems.push(item);
        }
        return resultItems;
    }
    save(path) {
        const resolvedPath = path_1.isAbsolute(path.toString())
            ? path_1.resolve(path.toString())
            : path_1.resolve(path_1.join(process.cwd(), path.toString()));
        fs_1.writeFileSync(resolvedPath, this.toText(), { encoding: "utf-8" });
    }
    toText() {
        const message = new Uint8Array([...this.secretKey.valueOf(), ...this.publicKey.valueOf()]);
        const pemEntry = new pemEntry_1.PemEntry(this.label, message);
        return pemEntry.toText();
    }
}
exports.UserPem = UserPem;
//# sourceMappingURL=userPem.js.map