"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Account = void 0;
const fs = __importStar(require("fs"));
const core_1 = require("../core");
const wallet_1 = require("../wallet");
/**
 * An abstraction representing an account (user or Smart Contract) on the Network.
 */
class Account {
    /**
     * Creates an account object from a secret key
     */
    constructor(secretKey, hrp = core_1.LibraryConfig.DefaultAddressHrp) {
        /**
         * Local copy of the account nonce.
         * Must be explicitly managed by client code.
         */
        this.nonce = 0n;
        this.secretKey = secretKey;
        this.publicKey = secretKey.generatePublicKey();
        this.address = this.publicKey.toAddress(hrp);
    }
    /**
     * Named constructor
     * Loads a secret key from a PEM file. PEM files may contain multiple accounts - thus, an (optional) "index" is used to select the desired secret key.
     * Returns an Account object, initialized with the secret key.
     */
    static async newFromPem(path, index = 0, hrp = core_1.LibraryConfig.DefaultAddressHrp) {
        const text = await fs.promises.readFile(path, { encoding: "utf8" });
        const userSigner = wallet_1.UserSigner.fromPem(text, index);
        return new Account(userSigner.secretKey, hrp);
    }
    /**
     * Named constructor
     * Loads a secret key from an encrypted keystore file. Handles both keystores that hold a mnemonic and ones that hold a secret key (legacy).
     * For keystores that hold an encrypted mnemonic, the optional "addressIndex" parameter is used to derive the desired secret key.
     * Returns an Account object, initialized with the secret key.
     */
    static newFromKeystore(filePath, password, addressIndex, hrp = core_1.LibraryConfig.DefaultAddressHrp) {
        const secretKey = wallet_1.UserWallet.loadSecretKey(filePath, password, addressIndex);
        return new Account(secretKey, hrp);
    }
    /**
     * Named constructor
     * Loads (derives) a secret key from a mnemonic. The optional "addressIndex" parameter is used to guide the derivation.
     * Returns an Account object, initialized with the secret key.
     */
    static newFromMnemonic(mnemonic, addressIndex = 0, hrp = core_1.LibraryConfig.DefaultAddressHrp) {
        const mnemonicHandler = wallet_1.Mnemonic.fromString(mnemonic);
        const secretKey = mnemonicHandler.deriveKey(addressIndex);
        return new Account(secretKey, hrp);
    }
    /**
     * Named constructor
     * Returns an Account object, initialized with the secret key.
     */
    static newFromKeypair(keypair, hrp = core_1.LibraryConfig.DefaultAddressHrp) {
        return new Account(keypair.secretKey, hrp);
    }
    /**
     * Increments (locally) the nonce (the account sequence number).
     */
    incrementNonce() {
        this.nonce = this.nonce + 1n;
    }
    /**
     * Signs using the secret key of the account.
     */
    async sign(data) {
        return this.secretKey.sign(data);
    }
    /**
     * Verifies the signature using the public key of the account.
     */
    async verify(data, signature) {
        return this.publicKey.verify(data, signature);
    }
    /**
     * Serializes the transaction, computes the signature and returns it.
     */
    async signTransaction(transaction) {
        const transactionComputer = new core_1.TransactionComputer();
        const serializedTransaction = transactionComputer.computeBytesForSigning(transaction);
        return this.secretKey.sign(serializedTransaction);
    }
    /**
     * Verifies the transaction signature using the public key of the account.
     */
    async verifyTransactionSignature(transaction, signature) {
        const transactionComputer = new core_1.TransactionComputer();
        const serializedTransaction = transactionComputer.computeBytesForVerifying(transaction);
        return this.publicKey.verify(serializedTransaction, signature);
    }
    /**
     * Serializes the message, computes the signature and returns it.
     */
    async signMessage(message) {
        const messageComputer = new core_1.MessageComputer();
        const serializedMessage = messageComputer.computeBytesForSigning(message);
        return this.secretKey.sign(serializedMessage);
    }
    /**
     * Verifies the message signature using the public key of the account.
     */
    async verifyMessageSignature(message, signature) {
        const messageComputer = new core_1.MessageComputer();
        const serializedMessage = messageComputer.computeBytesForVerifying(message);
        return this.publicKey.verify(serializedMessage, signature);
    }
    /**
     * Gets the nonce (the one from the object's state) and increments it.
     */
    getNonceThenIncrement() {
        let nonce = this.nonce;
        this.nonce = this.nonce + 1n;
        return nonce;
    }
    /**
     * Saves the wallet to a pem file
     */
    saveToPem(path) {
        const pem = new wallet_1.UserPem(this.address.toBech32(), this.secretKey);
        pem.save(path);
    }
    /**
     * Saves the wallet to a keystore file
     */
    saveToKeystore(path, password) {
        const wallet = wallet_1.UserWallet.fromSecretKey({ secretKey: this.secretKey, password });
        wallet.save(path, this.address.getHrp());
    }
}
exports.Account = Account;
//# sourceMappingURL=account.js.map