"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MainnetEntrypoint = exports.DevnetEntrypoint = exports.TestnetEntrypoint = exports.NetworkEntrypoint = void 0;
const accountManagement_1 = require("../accountManagement");
const accounts_1 = require("../accounts");
const core_1 = require("../core");
const delegation_1 = require("../delegation");
const multisig_1 = require("../multisig");
const multisigController_1 = require("../multisig/multisigController");
const networkProviders_1 = require("../networkProviders");
const smartContracts_1 = require("../smartContracts");
const smartContractController_1 = require("../smartContracts/smartContractController");
const tokenManagement_1 = require("../tokenManagement");
const transfers_1 = require("../transfers");
const wallet_1 = require("../wallet");
const config_1 = require("./config");
class NetworkEntrypoint {
    constructor(options) {
        if (options.networkProviderKind === "proxy") {
            this.networkProvider = new networkProviders_1.ProxyNetworkProvider(options.networkProviderUrl, {
                clientName: options.clientName,
            });
        }
        else if (options.networkProviderKind === "api") {
            this.networkProvider = new networkProviders_1.ApiNetworkProvider(options.networkProviderUrl, {
                clientName: options.clientName,
            });
        }
        else {
            throw new core_1.ErrInvalidNetworkProviderKind();
        }
        this.chainId = options.chainId;
    }
    /**
     * Creates a new Account by generating a new secret key and instantiating an UserSigner
     */
    async createAccount() {
        const secretKey = wallet_1.UserSecretKey.generate();
        return new accounts_1.Account(secretKey);
    }
    /**
     * Calls a faucet
     */
    async getAirdrop(_address) {
        throw new Error("Not implemented");
    }
    async signTransaction(transaction, account) {
        transaction.signature = await account.signTransaction(transaction);
    }
    /**
     * Verifies if the signature field is valid
     * @param transaction
     * @param account
     */
    async verifyTransactionSignature(transaction, account) {
        return await account.verifyTransactionSignature(transaction, transaction.signature);
    }
    /**
     * Verifies if message signature is valid
     * @param message
     * @param account
     */
    async verifyMessageSignature(message, account) {
        if (!message.address) {
            throw new Error("`address` property of Message is not set");
        }
        if (!message.signature) {
            throw new Error("`signature` property of Message is not set");
        }
        return await account.verifyMessageSignature(message, message.signature);
    }
    /**
     * Fetches the account nonce from the network.
     * @param address
     */
    async recallAccountNonce(address) {
        return (await this.networkProvider.getAccount(address)).nonce;
    }
    /**
     * Function of the network provider, promoted to the entrypoint.
     * @param transactions
     */
    sendTransactions(transactions) {
        return this.networkProvider.sendTransactions(transactions);
    }
    /**
     * Function of the network provider, promoted to the entrypoint.
     * @param transaction
     */
    sendTransaction(transaction) {
        return this.networkProvider.sendTransaction(transaction);
    }
    /**
     * Generic function to await a transaction on the network.
     * @param txHash
     */
    async awaitCompletedTransaction(txHash) {
        const transactionAwaiter = new core_1.TransactionWatcher(this.networkProvider);
        return transactionAwaiter.awaitCompleted(txHash);
    }
    getTransaction(txHash) {
        return this.networkProvider.getTransaction(txHash);
    }
    /**
     * Access to the underlying network provider.
     */
    createNetworkProvider() {
        return this.networkProvider;
    }
    createDelegationController() {
        return new delegation_1.DelegationController({ chainID: this.chainId, networkProvider: this.networkProvider });
    }
    createDelegationTransactionsFactory() {
        return new delegation_1.DelegationTransactionsFactory({ config: new core_1.TransactionsFactoryConfig({ chainID: this.chainId }) });
    }
    createAccountController() {
        return new accountManagement_1.AccountController({ chainID: this.chainId });
    }
    createAccountTransactionsFactory() {
        return new accountManagement_1.AccountTransactionsFactory({ config: new core_1.TransactionsFactoryConfig({ chainID: this.chainId }) });
    }
    createSmartContractController(abi) {
        return new smartContractController_1.SmartContractController({ chainID: this.chainId, networkProvider: this.networkProvider, abi });
    }
    createSmartContractTransactionsFactory() {
        return new smartContracts_1.SmartContractTransactionsFactory({
            config: new core_1.TransactionsFactoryConfig({ chainID: this.chainId }),
        });
    }
    createTokenManagementController() {
        return new tokenManagement_1.TokenManagementController({ chainID: this.chainId, networkProvider: this.networkProvider });
    }
    createTokenManagementTransactionsFactory() {
        return new tokenManagement_1.TokenManagementTransactionsFactory({
            config: new core_1.TransactionsFactoryConfig({ chainID: this.chainId }),
        });
    }
    createTransfersController() {
        return new transfers_1.TransfersController({ chainID: this.chainId });
    }
    createTransfersTransactionsFactory() {
        return new transfers_1.TransferTransactionsFactory({
            config: new core_1.TransactionsFactoryConfig({ chainID: this.chainId }),
        });
    }
    createMultisigController(abi) {
        return new multisigController_1.MultisigController({ chainID: this.chainId, networkProvider: this.networkProvider, abi: abi });
    }
    createMultisigTransactionsFactory(abi) {
        return new multisig_1.MultisigTransactionsFactory({
            config: new core_1.TransactionsFactoryConfig({ chainID: this.chainId }),
            abi: abi,
        });
    }
}
exports.NetworkEntrypoint = NetworkEntrypoint;
class TestnetEntrypoint extends NetworkEntrypoint {
    constructor(url, kind, clientName) {
        const entrypointConfig = new config_1.TestnetEntrypointConfig();
        super({
            networkProviderUrl: url || entrypointConfig.networkProviderUrl,
            networkProviderKind: kind || entrypointConfig.networkProviderKind,
            chainId: entrypointConfig.chainId,
            clientName: clientName,
        });
    }
}
exports.TestnetEntrypoint = TestnetEntrypoint;
class DevnetEntrypoint extends NetworkEntrypoint {
    constructor(url, kind, clientName) {
        const entrypointConfig = new config_1.DevnetEntrypointConfig();
        super({
            networkProviderUrl: url || entrypointConfig.networkProviderUrl,
            networkProviderKind: kind || entrypointConfig.networkProviderKind,
            chainId: entrypointConfig.chainId,
            clientName: clientName,
        });
    }
}
exports.DevnetEntrypoint = DevnetEntrypoint;
class MainnetEntrypoint extends NetworkEntrypoint {
    constructor(url, kind, clientName) {
        const entrypointConfig = new config_1.MainnetEntrypointConfig();
        super({
            networkProviderUrl: url || entrypointConfig.networkProviderUrl,
            networkProviderKind: kind || entrypointConfig.networkProviderKind,
            chainId: entrypointConfig.chainId,
            clientName: clientName,
        });
    }
}
exports.MainnetEntrypoint = MainnetEntrypoint;
//# sourceMappingURL=entrypoints.js.map