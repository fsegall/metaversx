"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionComputer = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const proto_1 = require("../proto");
const constants_1 = require("./constants");
const errors = __importStar(require("./errors"));
const createTransactionHasher = require("blake2b");
const createKeccakHash = require("keccak");
const TRANSACTION_HASH_LENGTH = 32;
/**
 * An utilitary class meant to work together with the {@link Transaction} class.
 */
class TransactionComputer {
    constructor() { }
    computeTransactionFee(transaction, networkConfig) {
        const moveBalanceGas = BigInt(networkConfig.minGasLimit + BigInt(transaction.data.length) * networkConfig.gasPerDataByte);
        if (moveBalanceGas > transaction.gasLimit) {
            throw new errors.ErrNotEnoughGas(parseInt(transaction.gasLimit.toString(), 10));
        }
        const gasPrice = transaction.gasPrice;
        const feeForMove = moveBalanceGas * gasPrice;
        if (moveBalanceGas === transaction.gasLimit) {
            return feeForMove;
        }
        const diff = transaction.gasLimit - moveBalanceGas;
        const modifiedGasPrice = BigInt(new bignumber_js_1.default(gasPrice.toString()).multipliedBy(new bignumber_js_1.default(networkConfig.gasPriceModifier)).toFixed(0));
        const processingFee = diff * modifiedGasPrice;
        return feeForMove + processingFee;
    }
    /**
     * Compute bytes for signing the transaction
     */
    computeBytesForSigning(transaction) {
        this.ensureValidTransactionFields(transaction);
        const plainTransaction = this.toPlainObject(transaction);
        const serialized = JSON.stringify(plainTransaction);
        return new Uint8Array(Buffer.from(serialized));
    }
    /**
     * Compute bytes for verifying the transaction signature
     */
    computeBytesForVerifying(transaction) {
        const isTxSignedByHash = this.hasOptionsSetForHashSigning(transaction);
        if (isTxSignedByHash) {
            return this.computeHashForSigning(transaction);
        }
        return this.computeBytesForSigning(transaction);
    }
    /**
     * Serializes the transaction then computes the hash; used for hash signing transactions.
     */
    computeHashForSigning(transaction) {
        const plainTransaction = this.toPlainObject(transaction);
        const signable = Buffer.from(JSON.stringify(plainTransaction));
        return createKeccakHash("keccak256").update(signable).digest();
    }
    computeTransactionHash(transaction) {
        const serializer = new proto_1.ProtoSerializer();
        const buffer = serializer.serializeTransaction(transaction);
        const hash = createTransactionHasher(TRANSACTION_HASH_LENGTH).update(buffer).digest("hex");
        return Buffer.from(hash, "hex").toString("hex");
    }
    /**
     * Returns true if the second least significant bit is set; returns false otherwise
     */
    hasOptionsSetForGuardedTransaction(transaction) {
        return (transaction.options & constants_1.TRANSACTION_OPTIONS_TX_GUARDED) == constants_1.TRANSACTION_OPTIONS_TX_GUARDED;
    }
    /**
     * Returns true if the least significant bit is set; returns false otherwise; should also have transaction.version >= 2
     */
    hasOptionsSetForHashSigning(transaction) {
        return (transaction.options & constants_1.TRANSACTION_OPTIONS_TX_HASH_SIGN) == constants_1.TRANSACTION_OPTIONS_TX_HASH_SIGN;
    }
    /**
     * Sets guardian address, transaction.version = 2, sets transaction.options second least significant bit
     */
    applyGuardian(transaction, guardian) {
        if (transaction.version < constants_1.MIN_TRANSACTION_VERSION_THAT_SUPPORTS_OPTIONS) {
            transaction.version = constants_1.MIN_TRANSACTION_VERSION_THAT_SUPPORTS_OPTIONS;
        }
        transaction.options = transaction.options | constants_1.TRANSACTION_OPTIONS_TX_GUARDED;
        transaction.guardian = guardian;
    }
    /**
     * Returns true if transaction.relayer is set; returns false otherwise;
     */
    isRelayedV3Transaction(transaction) {
        return !transaction.relayer.isEmpty();
    }
    /**
     * Sets the least significant bit of the `options` field; also ensures that `version` >= 2
     */
    applyOptionsForHashSigning(transaction) {
        if (transaction.version < constants_1.MIN_TRANSACTION_VERSION_THAT_SUPPORTS_OPTIONS) {
            transaction.version = constants_1.MIN_TRANSACTION_VERSION_THAT_SUPPORTS_OPTIONS;
        }
        transaction.options = transaction.options | constants_1.TRANSACTION_OPTIONS_TX_HASH_SIGN;
    }
    toPlainObject(transaction, withSignature) {
        let obj = {
            nonce: Number(transaction.nonce),
            value: transaction.value.toString(),
            receiver: transaction.receiver.toBech32(),
            sender: transaction.sender.toBech32(),
            senderUsername: this.toBase64OrUndefined(transaction.senderUsername),
            receiverUsername: this.toBase64OrUndefined(transaction.receiverUsername),
            gasPrice: Number(transaction.gasPrice),
            gasLimit: Number(transaction.gasLimit),
            data: this.toBase64OrUndefined(transaction.data),
        };
        if (withSignature) {
            obj.signature = this.toHexOrUndefined(transaction.signature);
        }
        obj.chainID = transaction.chainID;
        obj.version = transaction.version;
        obj.options = transaction.options ? transaction.options : undefined;
        obj.guardian = transaction.guardian.isEmpty() ? undefined : transaction.guardian.toBech32();
        obj.relayer = transaction.relayer?.isEmpty() ? undefined : transaction.relayer?.toBech32();
        return obj;
    }
    toHexOrUndefined(value) {
        return value && value.length ? Buffer.from(value).toString("hex") : undefined;
    }
    toBase64OrUndefined(value) {
        return value && value.length ? Buffer.from(value).toString("base64") : undefined;
    }
    ensureValidTransactionFields(transaction) {
        if (!transaction.chainID.length) {
            throw new errors.ErrBadUsage("The `chainID` field is not set");
        }
        if (transaction.version < constants_1.MIN_TRANSACTION_VERSION_THAT_SUPPORTS_OPTIONS) {
            if (this.hasOptionsSetForGuardedTransaction(transaction) || this.hasOptionsSetForHashSigning(transaction)) {
                throw new errors.ErrBadUsage(`Non-empty transaction options requires transaction version >= ${constants_1.MIN_TRANSACTION_VERSION_THAT_SUPPORTS_OPTIONS}`);
            }
        }
    }
}
exports.TransactionComputer = TransactionComputer;
//# sourceMappingURL=transactionComputer.js.map