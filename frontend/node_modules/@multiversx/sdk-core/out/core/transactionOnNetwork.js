"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionOnNetwork = exports.prepareTransactionForBroadcasting = void 0;
const transactionsOutcomeParsers_1 = require("../transactionsOutcomeParsers");
const address_1 = require("./address");
const transactionLogs_1 = require("./transactionLogs");
const transactionStatus_1 = require("./transactionStatus");
function prepareTransactionForBroadcasting(transaction) {
    return {
        nonce: Number(transaction.nonce),
        value: transaction.value.toString(),
        receiver: transaction.receiver.toBech32(),
        sender: transaction.sender.toBech32(),
        senderUsername: transaction.senderUsername
            ? Buffer.from(transaction.senderUsername).toString("base64")
            : undefined,
        receiverUsername: transaction.receiverUsername
            ? Buffer.from(transaction.receiverUsername).toString("base64")
            : undefined,
        gasPrice: Number(transaction.gasPrice),
        gasLimit: Number(transaction.gasLimit),
        data: transaction.data.length === 0 ? undefined : Buffer.from(transaction.data).toString("base64"),
        chainID: transaction.chainID,
        version: transaction.version,
        options: transaction.options,
        guardian: transaction.guardian.isEmpty() ? undefined : transaction.guardian.toBech32(),
        signature: Buffer.from(transaction.signature).toString("hex"),
        guardianSignature: transaction.guardianSignature.length === 0
            ? undefined
            : Buffer.from(transaction.guardianSignature).toString("hex"),
        relayer: transaction.relayer.isEmpty() ? undefined : transaction.relayer.toBech32(),
        relayerSignature: transaction.relayerSignature.length === 0
            ? undefined
            : Buffer.from(transaction.relayerSignature).toString("hex"),
    };
}
exports.prepareTransactionForBroadcasting = prepareTransactionForBroadcasting;
class TransactionOnNetwork {
    constructor(init) {
        this.raw = {};
        this.hash = "";
        this.type = "";
        this.nonce = 0n;
        this.round = 0n;
        this.epoch = 0;
        this.value = 0n;
        this.receiver = address_1.Address.empty();
        this.sender = address_1.Address.empty();
        this.senderShard = 0;
        this.receiverShard = 0;
        this.gasLimit = 0n;
        this.gasPrice = 0n;
        this.function = "";
        this.data = Buffer.from([]);
        this.version = 0;
        this.options = 0;
        this.signature = new Uint8Array();
        this.status = transactionStatus_1.TransactionStatus.createUnknown();
        this.timestamp = 0;
        this.miniblockHash = "";
        this.blockHash = "";
        this.smartContractResults = [];
        this.logs = new transactionLogs_1.TransactionLogs();
        Object.assign(this, init);
    }
    static fromProxyHttpResponse(txHash, response, processStatus) {
        const result = TransactionOnNetwork.fromHttpResponse(txHash, response);
        result.smartContractResults =
            response.smartContractResults?.map((result) => new transactionsOutcomeParsers_1.SmartContractResult({
                ...result,
                receiver: result.receiver ? new address_1.Address(result.receiver) : undefined,
                sender: result.sender ? new address_1.Address(result.sender) : undefined,
                data: Buffer.from(result.data ?? "", "utf-8"),
                raw: result,
            })) ?? [];
        if (processStatus) {
            result.status = processStatus;
            result.isCompleted = result.status.isSuccessful() || result.status.isFailed();
        }
        return result;
    }
    static fromSimulateResponse(originalTx, response) {
        const status = new transactionStatus_1.TransactionStatus(response["status"]);
        const txHash = response["hash"] ?? "";
        const scResults = [];
        const results = response["scResults"] || {};
        for (const hash in results) {
            const result = results[hash];
            const scResult = new transactionsOutcomeParsers_1.SmartContractResult({
                ...result,
                receiver: result.receiver ? new address_1.Address(result.receiver) : undefined,
                sender: result.sender ? new address_1.Address(result.sender) : undefined,
                raw: result,
            });
            scResults.push(scResult);
        }
        let result = new TransactionOnNetwork();
        result.hash = txHash;
        result.type = response.type || "";
        result.nonce = BigInt(originalTx.nonce || 0);
        result.round = -1n;
        result.epoch = -1;
        result.value = BigInt((originalTx.value || 0).toString());
        result.sender = new address_1.Address(originalTx.sender);
        result.receiver = new address_1.Address(originalTx.receiver);
        result.gasPrice = BigInt(originalTx.gasPrice) || 0n;
        result.gasLimit = BigInt(originalTx.gasLimit) || 0n;
        result.function = "";
        result.data = originalTx.data ? Buffer.from(originalTx.data?.toString()) : Buffer.from("");
        result.version = originalTx.version || 1;
        result.options = originalTx.options || 0;
        result.timestamp = 0;
        result.miniblockHash = "";
        result.blockHash = "";
        result.logs = transactionLogs_1.TransactionLogs.fromHttpResponse(response.logs || {});
        result.raw = response;
        result.smartContractResults = scResults;
        result.status = status;
        result.isCompleted = status.isSuccessful() || status.isFailed();
        return result;
    }
    static fromApiHttpResponse(txHash, response) {
        const result = TransactionOnNetwork.fromHttpResponse(txHash, response);
        result.smartContractResults =
            response.results?.map((result) => new transactionsOutcomeParsers_1.SmartContractResult({
                ...result,
                receiver: result.receiver ? new address_1.Address(result.receiver) : undefined,
                sender: result.sender ? new address_1.Address(result.sender) : undefined,
                data: Buffer.from(result.data ?? "", "base64"),
                raw: result,
            })) ?? [];
        result.isCompleted = !result.status.isPending();
        return result;
    }
    static fromHttpResponse(txHash, response) {
        let result = new TransactionOnNetwork();
        result.hash = txHash;
        result.type = response.type || "";
        result.nonce = BigInt(response.nonce || 0);
        result.round = BigInt(response.round || 0);
        result.epoch = response.epoch || 0;
        result.value = BigInt((response.value || 0).toString());
        result.sender = new address_1.Address(response.sender);
        result.receiver = new address_1.Address(response.receiver);
        result.gasPrice = BigInt(response.gasPrice) || 0n;
        result.gasLimit = BigInt(response.gasLimit) || 0n;
        result.function = response.function || "";
        result.version = response.version || 1;
        result.options = response.options || 0;
        result.data = Buffer.from(response.data || "", "base64");
        result.status = new transactionStatus_1.TransactionStatus(response.status);
        result.timestamp = response.timestamp || 0;
        result.miniblockHash = response.miniblockHash || "";
        result.blockHash = response.blockHash || "";
        result.logs = transactionLogs_1.TransactionLogs.fromHttpResponse(response.logs || {});
        result.raw = response;
        return result;
    }
    getDateTime() {
        return new Date(this.timestamp * 1000);
    }
}
exports.TransactionOnNetwork = TransactionOnNetwork;
//# sourceMappingURL=transactionOnNetwork.js.map