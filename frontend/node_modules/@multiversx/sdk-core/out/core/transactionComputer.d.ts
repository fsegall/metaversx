import { Address } from "./address";
import { INetworkConfig } from "./interfaces";
import { Transaction } from "./transaction";
/**
 * An utilitary class meant to work together with the {@link Transaction} class.
 */
export declare class TransactionComputer {
    constructor();
    computeTransactionFee(transaction: {
        gasPrice: bigint;
        gasLimit: bigint;
        data: Uint8Array;
    }, networkConfig: INetworkConfig): bigint;
    /**
     * Compute bytes for signing the transaction
     */
    computeBytesForSigning(transaction: Transaction): Uint8Array;
    /**
     * Compute bytes for verifying the transaction signature
     */
    computeBytesForVerifying(transaction: Transaction): Uint8Array;
    /**
     * Serializes the transaction then computes the hash; used for hash signing transactions.
     */
    computeHashForSigning(transaction: Transaction): Uint8Array;
    computeTransactionHash(transaction: Transaction): string;
    /**
     * Returns true if the second least significant bit is set; returns false otherwise
     */
    hasOptionsSetForGuardedTransaction(transaction: Transaction): boolean;
    /**
     * Returns true if the least significant bit is set; returns false otherwise; should also have transaction.version >= 2
     */
    hasOptionsSetForHashSigning(transaction: Transaction): boolean;
    /**
     * Sets guardian address, transaction.version = 2, sets transaction.options second least significant bit
     */
    applyGuardian(transaction: Transaction, guardian: Address): void;
    /**
     * Returns true if transaction.relayer is set; returns false otherwise;
     */
    isRelayedV3Transaction(transaction: Transaction): boolean;
    /**
     * Sets the least significant bit of the `options` field; also ensures that `version` >= 2
     */
    applyOptionsForHashSigning(transaction: Transaction): void;
    private toPlainObject;
    private toHexOrUndefined;
    private toBase64OrUndefined;
    private ensureValidTransactionFields;
}
