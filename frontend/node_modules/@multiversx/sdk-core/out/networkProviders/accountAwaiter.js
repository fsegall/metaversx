"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountAwaiter = void 0;
const errors_1 = require("../core/errors");
const constants_1 = require("./constants");
class AccountAwaiter {
    /**
     * AccountAwaiter allows one to await until a specific event occurs on a given address.
     *
     * @param fetcher - Used to fetch the account of the network.
     * @param pollingIntervalInMilliseconds - The polling interval, in milliseconds.
     * @param timeoutIntervalInMilliseconds - The timeout, in milliseconds.
     * @param patienceTimeInMilliseconds - The patience, an extra time (in milliseconds) to wait, after the account has reached its desired condition.
     */
    constructor(options) {
        this.fetcher = options.fetcher;
        this.pollingIntervalInMilliseconds =
            options.pollingIntervalInMilliseconds ?? constants_1.DEFAULT_ACCOUNT_AWAITING_POLLING_TIMEOUT_IN_MILLISECONDS;
        this.timeoutIntervalInMilliseconds =
            options.timeoutIntervalInMilliseconds ?? constants_1.DEFAULT_ACCOUNT_AWAITING_TIMEOUT_IN_MILLISECONDS;
        this.patienceTimeInMilliseconds =
            options.patienceTimeInMilliseconds ?? constants_1.DEFAULT_ACCOUNT_AWAITING_PATIENCE_IN_MILLISECONDS;
    }
    /**
     * Waits until the condition is satisfied.
     *
     * @param address - The address to monitor.
     * @param condition - A callable that evaluates the desired condition.
     */
    async awaitOnCondition(address, condition) {
        const doFetch = async () => await this.fetcher.getAccount(address);
        return this.awaitConditionally(condition, doFetch, new errors_1.ExpectedAccountConditionNotReachedError());
    }
    async awaitConditionally(isSatisfied, doFetch, error) {
        let isConditionSatisfied = false;
        let fetchedData = null;
        const maxNumberOfRetries = Math.floor(this.timeoutIntervalInMilliseconds / this.pollingIntervalInMilliseconds);
        let numberOfRetries = 0;
        while (numberOfRetries < maxNumberOfRetries) {
            try {
                fetchedData = await doFetch();
                isConditionSatisfied = isSatisfied(fetchedData);
                if (isConditionSatisfied) {
                    break;
                }
            }
            catch (ex) {
                throw ex;
            }
            numberOfRetries += 1;
            await this._sleep(this.pollingIntervalInMilliseconds);
        }
        if (!fetchedData || !isConditionSatisfied) {
            throw error;
        }
        if (this.patienceTimeInMilliseconds) {
            await this._sleep(this.patienceTimeInMilliseconds);
            return doFetch();
        }
        return fetchedData;
    }
    async _sleep(milliseconds) {
        return new Promise((resolve) => setTimeout(resolve, milliseconds));
    }
}
exports.AccountAwaiter = AccountAwaiter;
//# sourceMappingURL=accountAwaiter.js.map