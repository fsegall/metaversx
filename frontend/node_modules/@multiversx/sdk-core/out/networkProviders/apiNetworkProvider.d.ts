import { Address, SmartContractQuery, SmartContractQueryResponse, Token, Transaction, TransactionOnNetwork, TransactionStatus } from "../core";
import { AccountOnNetwork, AccountStorage, AccountStorageEntry } from "./accounts";
import { BlockOnNetwork } from "./blocks";
import { INetworkProvider, IPagination } from "./interface";
import { NetworkConfig } from "./networkConfig";
import { NetworkProviderConfig } from "./networkProviderConfig";
import { NetworkStatus } from "./networkStatus";
import { AwaitingOptions, TransactionCostResponse } from "./resources";
import { DefinitionOfFungibleTokenOnNetwork, DefinitionOfTokenCollectionOnNetwork } from "./tokenDefinitions";
import { TokenAmountOnNetwork } from "./tokens";
export declare class ApiNetworkProvider implements INetworkProvider {
    private url;
    private config;
    private backingProxyNetworkProvider;
    private userAgentPrefix;
    private axios;
    constructor(url: string, config?: NetworkProviderConfig);
    private getProxyConfig;
    getNetworkConfig(): Promise<NetworkConfig>;
    getNetworkStatus(shard?: number): Promise<NetworkStatus>;
    getBlock(blockHash: string): Promise<BlockOnNetwork>;
    getLatestBlock(): Promise<BlockOnNetwork>;
    getAccount(address: Address): Promise<AccountOnNetwork>;
    getAccountStorage(address: Address): Promise<AccountStorage>;
    getAccountStorageEntry(address: Address, entryKey: string): Promise<AccountStorageEntry>;
    awaitAccountOnCondition(address: Address, condition: (account: AccountOnNetwork) => boolean, options?: AwaitingOptions): Promise<AccountOnNetwork>;
    sendTransaction(tx: Transaction): Promise<string>;
    simulateTransaction(tx: Transaction, checkSignature?: boolean): Promise<any>;
    estimateTransactionCost(tx: Transaction): Promise<TransactionCostResponse>;
    sendTransactions(txs: Transaction[]): Promise<[number, string[]]>;
    getTransaction(txHash: string): Promise<TransactionOnNetwork>;
    getTransactions(address: Address): Promise<TransactionOnNetwork[]>;
    getTransactionStatus(txHash: string): Promise<TransactionStatus>;
    awaitTransactionOnCondition(transactionHash: string, condition: (account: TransactionOnNetwork) => boolean, options?: AwaitingOptions): Promise<TransactionOnNetwork>;
    awaitTransactionCompleted(transactionHash: string, options?: AwaitingOptions): Promise<TransactionOnNetwork>;
    getTokenOfAccount(address: Address, token: Token): Promise<TokenAmountOnNetwork>;
    getFungibleTokensOfAccount(address: Address, pagination?: IPagination): Promise<TokenAmountOnNetwork[]>;
    getNonFungibleTokensOfAccount(address: Address, pagination?: IPagination): Promise<TokenAmountOnNetwork[]>;
    getDefinitionOfFungibleToken(tokenIdentifier: string): Promise<DefinitionOfFungibleTokenOnNetwork>;
    getDefinitionOfTokenCollection(collection: string): Promise<DefinitionOfTokenCollectionOnNetwork>;
    queryContract(query: SmartContractQuery): Promise<SmartContractQueryResponse>;
    doGetGeneric(resourceUrl: string): Promise<any>;
    doPostGeneric(resourceUrl: string, payload: any): Promise<any>;
    private buildPaginationParams;
    private doGet;
    private doPost;
    private handleApiError;
}
