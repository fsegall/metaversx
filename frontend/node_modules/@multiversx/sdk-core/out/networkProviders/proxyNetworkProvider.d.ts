import { Address, SmartContractQuery, SmartContractQueryResponse, Token, Transaction, TransactionOnNetwork, TransactionStatus } from "../core";
import { AccountOnNetwork, AccountStorage, AccountStorageEntry, GuardianData } from "./accounts";
import { BlockOnNetwork } from "./blocks";
import { INetworkProvider } from "./interface";
import { NetworkConfig } from "./networkConfig";
import { NetworkProviderConfig } from "./networkProviderConfig";
import { NetworkStatus } from "./networkStatus";
import { AwaitingOptions, TransactionCostResponse } from "./resources";
import { DefinitionOfFungibleTokenOnNetwork, DefinitionOfTokenCollectionOnNetwork } from "./tokenDefinitions";
import { TokenAmountOnNetwork } from "./tokens";
export declare class ProxyNetworkProvider implements INetworkProvider {
    private url;
    private config;
    private userAgentPrefix;
    private axios;
    constructor(url: string, config?: NetworkProviderConfig);
    getNetworkConfig(): Promise<NetworkConfig>;
    getNetworkStatus(shard?: number): Promise<NetworkStatus>;
    getBlock(args: {
        shard: number;
        blockHash?: string;
        blockNonce?: bigint;
    }): Promise<BlockOnNetwork>;
    getLatestBlock(shard?: number): Promise<BlockOnNetwork>;
    getAccount(address: Address): Promise<AccountOnNetwork>;
    getGuardianData(address: Address): Promise<GuardianData>;
    getAccountStorage(address: Address): Promise<AccountStorage>;
    getAccountStorageEntry(address: Address, entryKey: string): Promise<AccountStorageEntry>;
    awaitAccountOnCondition(address: Address, condition: (account: AccountOnNetwork) => boolean, options?: AwaitingOptions): Promise<AccountOnNetwork>;
    sendTransaction(tx: Transaction): Promise<string>;
    simulateTransaction(tx: Transaction, checkSignature?: boolean): Promise<any>;
    estimateTransactionCost(tx: Transaction): Promise<TransactionCostResponse>;
    sendTransactions(txs: Transaction[]): Promise<[number, string[]]>;
    getTransaction(txHash: string): Promise<TransactionOnNetwork>;
    awaitTransactionOnCondition(transactionHash: string, condition: (account: TransactionOnNetwork) => boolean, options?: AwaitingOptions): Promise<TransactionOnNetwork>;
    awaitTransactionCompleted(transactionHash: string, options?: AwaitingOptions): Promise<TransactionOnNetwork>;
    getTokenOfAccount(address: Address, token: Token): Promise<TokenAmountOnNetwork>;
    getFungibleTokensOfAccount(address: Address): Promise<TokenAmountOnNetwork[]>;
    getNonFungibleTokensOfAccount(address: Address): Promise<TokenAmountOnNetwork[]>;
    getTransactionStatus(txHash: string): Promise<TransactionStatus>;
    getDefinitionOfFungibleToken(tokenIdentifier: string): Promise<DefinitionOfFungibleTokenOnNetwork>;
    queryContract(query: SmartContractQuery): Promise<SmartContractQueryResponse>;
    private getTokenProperties;
    getDefinitionOfTokenCollection(collection: string): Promise<DefinitionOfTokenCollectionOnNetwork>;
    doGetGeneric(resourceUrl: string): Promise<any>;
    doPostGeneric(resourceUrl: string, payload: any): Promise<any>;
    private doGet;
    private doPost;
    private buildUrlWithQueryParameters;
    private handleApiError;
}
