"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GovernanceController = void 0;
const abi_1 = require("../abi");
const core_1 = require("../core");
const constants_1 = require("../core/constants");
const smartContracts_1 = require("../smartContracts");
const governanceTransactionsFactory_1 = require("./governanceTransactionsFactory");
const governanceTransactionsOutcomeParser_1 = require("./governanceTransactionsOutcomeParser");
class GovernanceController extends core_1.BaseController {
    constructor(options) {
        super();
        this.governanceFactory = new governanceTransactionsFactory_1.GovernanceTransactionsFactory({
            config: new core_1.TransactionsFactoryConfig({ chainID: options.chainID }),
        });
        this.smartContractController = new smartContracts_1.SmartContractController({
            chainID: options.chainID,
            networkProvider: options.networkProvider,
        });
        this.addressHrp = options.addressHrp ?? core_1.LibraryConfig.DefaultAddressHrp;
        this.parser = new governanceTransactionsOutcomeParser_1.GovernanceTransactionsOutcomeParser({ addressHrp: this.addressHrp });
        this.governanceContract = core_1.Address.newFromHex(constants_1.GOVERNANCE_CONTRACT_ADDRESS_HEX, this.addressHrp);
        this.transactionAwaiter = new core_1.TransactionWatcher(options.networkProvider);
        this.serializer = new abi_1.ArgSerializer();
    }
    async createTransactionForNewProposal(sender, nonce, options) {
        const transaction = this.governanceFactory.createTransactionForNewProposal(sender.address, options);
        transaction.guardian = options.guardian ?? core_1.Address.empty();
        transaction.relayer = options.relayer ?? core_1.Address.empty();
        transaction.nonce = nonce;
        this.setTransactionGasOptions(transaction, options);
        this.setVersionAndOptionsForGuardian(transaction);
        transaction.signature = await sender.signTransaction(transaction);
        return transaction;
    }
    parseNewProposal(transaction) {
        return this.parser.parseNewProposal(transaction);
    }
    async awaitCompletedProposeProposal(txHash) {
        const transaction = await this.transactionAwaiter.awaitCompleted(txHash);
        return this.parseNewProposal(transaction);
    }
    async createTransactionForVoting(sender, nonce, options) {
        const transaction = this.governanceFactory.createTransactionForVoting(sender.address, options);
        transaction.guardian = options.guardian ?? core_1.Address.empty();
        transaction.relayer = options.relayer ?? core_1.Address.empty();
        transaction.nonce = nonce;
        this.setTransactionGasOptions(transaction, options);
        this.setVersionAndOptionsForGuardian(transaction);
        transaction.signature = await sender.signTransaction(transaction);
        return transaction;
    }
    parseVote(transaction) {
        return this.parser.parseVote(transaction);
    }
    async awaitCompletedVote(txHash) {
        const transaction = await this.transactionAwaiter.awaitCompleted(txHash);
        return this.parseVote(transaction);
    }
    async createTransactionForClosingProposal(sender, nonce, options) {
        const transaction = this.governanceFactory.createTransactionForClosingProposal(sender.address, options);
        transaction.guardian = options.guardian ?? core_1.Address.empty();
        transaction.relayer = options.relayer ?? core_1.Address.empty();
        transaction.nonce = nonce;
        this.setTransactionGasOptions(transaction, options);
        this.setVersionAndOptionsForGuardian(transaction);
        transaction.signature = await sender.signTransaction(transaction);
        return transaction;
    }
    parseCloseProposal(transaction) {
        return this.parser.parseCloseProposal(transaction);
    }
    async awaitCompletedCloseProposal(txHash) {
        const transaction = await this.transactionAwaiter.awaitCompleted(txHash);
        return this.parseCloseProposal(transaction);
    }
    async createTransactionForClearingEndedProposals(sender, nonce, options) {
        const transaction = this.governanceFactory.createTransactionForClearingEndedProposals(sender.address, options);
        transaction.guardian = options.guardian ?? core_1.Address.empty();
        transaction.relayer = options.relayer ?? core_1.Address.empty();
        transaction.nonce = nonce;
        this.setTransactionGasOptions(transaction, options);
        this.setVersionAndOptionsForGuardian(transaction);
        transaction.signature = await sender.signTransaction(transaction);
        return transaction;
    }
    async createTransactionForClaimingAccumulatedFees(sender, nonce, options) {
        const transaction = this.governanceFactory.createTransactionForClaimingAccumulatedFees(sender.address);
        transaction.guardian = options.guardian ?? core_1.Address.empty();
        transaction.relayer = options.relayer ?? core_1.Address.empty();
        transaction.nonce = nonce;
        this.setTransactionGasOptions(transaction, options);
        this.setVersionAndOptionsForGuardian(transaction);
        transaction.signature = await sender.signTransaction(transaction);
        return transaction;
    }
    async createTransactionForChangingConfig(sender, nonce, options) {
        const transaction = this.governanceFactory.createTransactionForChangingConfig(sender.address, options);
        transaction.guardian = options.guardian ?? core_1.Address.empty();
        transaction.relayer = options.relayer ?? core_1.Address.empty();
        transaction.nonce = nonce;
        this.setTransactionGasOptions(transaction, options);
        this.setVersionAndOptionsForGuardian(transaction);
        transaction.signature = await sender.signTransaction(transaction);
        return transaction;
    }
    async getVotingPower(address) {
        const result = await this.smartContractController.query({
            contract: this.governanceContract,
            function: "viewVotingPower",
            arguments: [new abi_1.AddressValue(address)],
        });
        const votingPower = { type: new abi_1.BigUIntType() };
        const data = this.serializer.buffersToValues(result, [votingPower]);
        return BigInt(data[0].valueOf().toFixed());
    }
    async getConfig() {
        const result = await this.smartContractController.query({
            contract: this.governanceContract,
            function: "viewConfig",
            arguments: [],
        });
        const proposalFee = BigInt(Buffer.from(result[0]).toString());
        const minQuorum = Number(Buffer.from(result[1]).toString());
        const minPassThreshold = Number(Buffer.from(result[2]).toString());
        const minVetoThreshold = Number(Buffer.from(result[3]).toString());
        const lastProposalNonce = Number(Buffer.from(result[4]).toString());
        return {
            proposalFee,
            minQuorum,
            minPassThreshold,
            minVetoThreshold,
            lastProposalNonce,
        };
    }
    async getProposal(proposalNonce) {
        const result = await this.smartContractController.query({
            contract: this.governanceContract,
            function: "viewProposal",
            arguments: [new abi_1.BigUIntValue(proposalNonce)],
        });
        const proposalCost = { type: new abi_1.BigUIntType() };
        const commitHash = { type: new abi_1.StringType() };
        const nonce = { type: new abi_1.BigUIntType() };
        const issuer = { type: new abi_1.AddressType() };
        const startVoteEpoch = { type: new abi_1.BigUIntType() };
        const endVoteEpoch = { type: new abi_1.BigUIntType() };
        const quorumStake = { type: new abi_1.BigUIntType() };
        const numVotesYes = { type: new abi_1.BigUIntType() };
        const numVotesNo = { type: new abi_1.BigUIntType() };
        const numVotesVeto = { type: new abi_1.BigUIntType() };
        const numVotesAbstain = { type: new abi_1.BigUIntType() };
        const data = this.serializer.buffersToValues(result.slice(0, 11), [
            proposalCost,
            commitHash,
            nonce,
            issuer,
            startVoteEpoch,
            endVoteEpoch,
            quorumStake,
            numVotesYes,
            numVotesNo,
            numVotesVeto,
            numVotesAbstain,
        ]);
        const isClosed = Buffer.from(result[11]).toString() === "true";
        const isPassed = Buffer.from(result[12]).toString() === "true";
        return {
            cost: BigInt(data[0].valueOf().toFixed()),
            commitHash: data[1].valueOf(),
            nonce: Number(data[2].valueOf().toString()),
            issuer: data[3].valueOf(),
            startVoteEpoch: Number(data[4].valueOf().toString()),
            endVoteEpoch: Number(data[5].valueOf().toString()),
            quorumStake: BigInt(data[6].valueOf().toFixed()),
            numYesVotes: BigInt(data[7].valueOf().toFixed()),
            numNoVotes: BigInt(data[8].valueOf().toFixed()),
            numVetoVotes: BigInt(data[9].valueOf().toFixed()),
            numAbstainVotes: BigInt(data[10].valueOf().toFixed()),
            isClosed: isClosed,
            isPassed: isPassed,
        };
    }
    async getDelegatedVoteInfo() {
        const result = await this.smartContractController.query({
            contract: this.governanceContract,
            function: "viewDelegatedVoteInfo",
            arguments: [],
        });
        const usedStake = BigInt(Buffer.from(result[0]).toString());
        const usedPower = BigInt(Buffer.from(result[1]).toString());
        const totalStake = BigInt(Buffer.from(result[2]).toString());
        const totalPower = BigInt(Buffer.from(result[3]).toString());
        return {
            usedStake,
            usedPower,
            totalStake,
            totalPower,
        };
    }
}
exports.GovernanceController = GovernanceController;
//# sourceMappingURL=governanceController.js.map