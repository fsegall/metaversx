"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GovernanceTransactionsOutcomeParser = void 0;
const abi_1 = require("../abi");
const core_1 = require("../core");
const transactionsOutcomeParsers_1 = require("../transactionsOutcomeParsers");
class GovernanceTransactionsOutcomeParser {
    constructor(options) {
        this.addressHrp = options.addressHrp ?? core_1.LibraryConfig.DefaultAddressHrp;
        this.serializer = new abi_1.ArgSerializer();
    }
    parseNewProposal(transactionOnNetwork) {
        this.ensureNoError(transactionOnNetwork.logs.events);
        const events = transactionsOutcomeParsers_1.findEventsByIdentifier(transactionOnNetwork, "proposal");
        const proposalNonce = { type: new abi_1.BigUIntType() };
        const commitHash = { type: new abi_1.StringType() };
        const startVoteEpoch = { type: new abi_1.BigUIntType() };
        const endVoteEpoch = { type: new abi_1.BigUIntType() };
        const outcome = [];
        for (const event of events) {
            const data = this.serializer.buffersToValues(event.topics.map((topic) => Buffer.from(topic)), [proposalNonce, commitHash, startVoteEpoch, endVoteEpoch]);
            outcome.push({
                proposalNonce: data[0].valueOf(),
                commitHash: data[1].valueOf(),
                startVoteEpoch: data[2].valueOf(),
                endVoteEpoch: data[3].valueOf(),
            });
        }
        return outcome;
    }
    parseVote(transactionOnNetwork) {
        this.ensureNoError(transactionOnNetwork.logs.events);
        const events = transactionsOutcomeParsers_1.findEventsByIdentifier(transactionOnNetwork, "vote");
        const proposalToVote = { type: new abi_1.BigUIntType() };
        const vote = { type: new abi_1.StringType() };
        const totalStake = { type: new abi_1.BigUIntType() };
        const votingPower = { type: new abi_1.BigUIntType() };
        const outcome = [];
        for (const event of events) {
            const data = this.serializer.buffersToValues(event.topics.map((topic) => Buffer.from(topic)), [proposalToVote, vote, totalStake, votingPower]);
            outcome.push({
                proposalNonce: Number(data[0].toString()),
                vote: data[1].valueOf(),
                totalStake: BigInt(data[2].valueOf().toFixed()),
                votingPower: BigInt(data[3].valueOf().toFixed()),
            });
        }
        return outcome;
    }
    parseDelegateVote(transactionOnNetwork) {
        this.ensureNoError(transactionOnNetwork.logs.events);
        const events = transactionsOutcomeParsers_1.findEventsByIdentifier(transactionOnNetwork, "delegateVote");
        const proposalToVote = { type: new abi_1.BigUIntType() };
        const vote = { type: new abi_1.StringType() };
        const voter = { type: new abi_1.AddressType() };
        const userStake = { type: new abi_1.BigUIntType() };
        const votingPower = { type: new abi_1.BigUIntType() };
        const outcome = [];
        for (const event of events) {
            const data = this.serializer.buffersToValues(event.topics.map((topic) => Buffer.from(topic)), [proposalToVote, vote, voter, userStake, votingPower]);
            outcome.push({
                proposalNonce: Number(data[0].toString()),
                vote: data[1].valueOf(),
                voter: new core_1.Address(data[2].valueOf().getPublicKey(), this.addressHrp),
                userStake: BigInt(data[3].valueOf().toFixed()),
                votingPower: BigInt(data[4].valueOf().toFixed()),
            });
        }
        return outcome;
    }
    parseCloseProposal(transactionOnNetwork) {
        this.ensureNoError(transactionOnNetwork.logs.events);
        const events = transactionsOutcomeParsers_1.findEventsByIdentifier(transactionOnNetwork, "closeProposal");
        const outcome = [];
        for (const event of events) {
            const commitHash = Buffer.from(event.topics[0]).toString();
            const passed = Buffer.from(event.topics[1]).toString() === "true";
            outcome.push({
                commitHash: commitHash,
                passed: passed,
            });
        }
        return outcome;
    }
    ensureNoError(transactionEvents) {
        for (const event of transactionEvents) {
            if (event.identifier == "signalError") {
                const data = Buffer.from(event.additionalData[0]?.toString().slice(1)).toString() || "";
                const message = this.decodeTopicAsString(event.topics[1]);
                throw new core_1.ErrParseTransactionOutcome(`encountered signalError: ${message} (${Buffer.from(data, "hex").toString()})`);
            }
        }
    }
    decodeTopicAsString(topic) {
        return Buffer.from(topic).toString();
    }
}
exports.GovernanceTransactionsOutcomeParser = GovernanceTransactionsOutcomeParser;
//# sourceMappingURL=governanceTransactionsOutcomeParser.js.map