"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SmartContractController = void 0;
const abi_1 = require("../abi");
const core_1 = require("../core");
const transactionsOutcomeParsers_1 = require("../transactionsOutcomeParsers");
const smartContractTransactionsFactory_1 = require("./smartContractTransactionsFactory");
class SmartContractController extends core_1.BaseController {
    constructor(options) {
        super();
        this.factory = new smartContractTransactionsFactory_1.SmartContractTransactionsFactory({
            config: new core_1.TransactionsFactoryConfig({ chainID: options.chainID }),
            abi: options.abi,
        });
        this.parser = new transactionsOutcomeParsers_1.SmartContractTransactionsOutcomeParser(options);
        this.transactionWatcher = new core_1.TransactionWatcher(options.networkProvider);
        this.networkProvider = options.networkProvider;
        this.abi = options.abi;
    }
    async createTransactionForDeploy(sender, nonce, options) {
        const transaction = this.factory.createTransactionForDeploy(sender.address, options);
        transaction.guardian = options.guardian ?? core_1.Address.empty();
        transaction.relayer = options.relayer ?? core_1.Address.empty();
        transaction.nonce = nonce;
        this.setTransactionGasOptions(transaction, options);
        this.setVersionAndOptionsForGuardian(transaction);
        transaction.signature = await sender.signTransaction(transaction);
        return transaction;
    }
    parseDeploy(transactionOnNetwork) {
        return this.parser.parseDeploy({ transactionOnNetwork });
    }
    async awaitCompletedDeploy(txHash) {
        const transaction = await this.transactionWatcher.awaitCompleted(txHash);
        return this.parseDeploy(transaction);
    }
    async createTransactionForUpgrade(sender, nonce, options) {
        const transaction = this.factory.createTransactionForUpgrade(sender.address, options);
        transaction.guardian = options.guardian ?? core_1.Address.empty();
        transaction.relayer = options.relayer ?? core_1.Address.empty();
        transaction.nonce = nonce;
        this.setTransactionGasOptions(transaction, options);
        this.setVersionAndOptionsForGuardian(transaction);
        transaction.signature = await sender.signTransaction(transaction);
        return transaction;
    }
    async createTransactionForExecute(sender, nonce, options) {
        const transaction = this.factory.createTransactionForExecute(sender.address, options);
        transaction.guardian = options.guardian ?? core_1.Address.empty();
        transaction.relayer = options.relayer ?? core_1.Address.empty();
        transaction.nonce = nonce;
        this.setTransactionGasOptions(transaction, options);
        this.setVersionAndOptionsForGuardian(transaction);
        transaction.signature = await sender.signTransaction(transaction);
        return transaction;
    }
    parseExecute(transactionOnNetwork) {
        return this.parser.parseExecute({ transactionOnNetwork });
    }
    async awaitCompletedExecute(txHash) {
        const transaction = await this.transactionWatcher.awaitCompleted(txHash);
        return this.parseExecute(transaction);
    }
    async query(options) {
        const query = this.createQuery(options);
        const queryResponse = await this.runQuery(query);
        this.raiseForStatus(queryResponse);
        return this.parseQueryResponse(queryResponse);
    }
    async runQuery(query) {
        const queryResponse = await this.networkProvider.queryContract(query);
        return queryResponse;
    }
    createQuery(options) {
        const preparedArguments = this.encodeArguments(options.function, options.arguments);
        return new core_1.SmartContractQuery({
            contract: options.contract,
            caller: options.caller,
            function: options.function,
            arguments: preparedArguments,
            value: options.value,
        });
    }
    raiseForStatus(queryResponse) {
        const isOk = queryResponse.returnCode === "ok";
        if (!isOk) {
            throw new core_1.ErrSmartContractQuery(queryResponse.returnCode, queryResponse.returnMessage);
        }
    }
    parseQueryResponse(response) {
        if (!this.abi) {
            return response.returnDataParts;
        }
        const argsSerializer = new abi_1.ArgSerializer();
        const functionName = response.function;
        const endpoint = this.abi.getEndpoint(functionName);
        const parts = response.returnDataParts.map((part) => Buffer.from(part));
        let values = argsSerializer.buffersToValues(parts, endpoint.output);
        return values.map((value) => value.valueOf());
    }
    encodeArguments(functionName, args) {
        const endpoint = this.abi?.getEndpoint(functionName);
        if (endpoint) {
            const typedArgs = abi_1.NativeSerializer.nativeToTypedValues(args, endpoint);
            return new abi_1.ArgSerializer().valuesToBuffers(typedArgs);
        }
        if (this.areArgsOfTypedValue(args)) {
            return new abi_1.ArgSerializer().valuesToBuffers(args);
        }
        if (this.areArgsBuffers(args)) {
            return args.map((arg) => Buffer.from(arg));
        }
        throw new core_1.Err("cannot encode arguments: when ABI is not available, they must be either typed values or buffers");
    }
    areArgsOfTypedValue(args) {
        return args.every((arg) => abi_1.isTyped(arg));
    }
    areArgsBuffers(args) {
        for (const arg of args) {
            if (!ArrayBuffer.isView(arg)) {
                return false;
            }
        }
        return true;
    }
}
exports.SmartContractController = SmartContractController;
//# sourceMappingURL=smartContractController.js.map