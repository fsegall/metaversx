import { Abi } from "../abi";
import { BaseController, BaseControllerInput, IAccount, SmartContractQuery, SmartContractQueryInput, SmartContractQueryResponse, Transaction, TransactionOnNetwork } from "../core";
import { INetworkProvider } from "../networkProviders/interface";
import * as resources from "./resources";
import { SmartContractTransactionsFactory } from "./smartContractTransactionsFactory";
export declare class SmartContractController extends BaseController {
    protected factory: SmartContractTransactionsFactory;
    private parser;
    private transactionWatcher;
    private networkProvider;
    protected abi?: Abi;
    constructor(options: {
        chainID: string;
        networkProvider: INetworkProvider;
        abi?: Abi;
    });
    createTransactionForDeploy(sender: IAccount, nonce: bigint, options: resources.ContractDeployInput & BaseControllerInput): Promise<Transaction>;
    parseDeploy(transactionOnNetwork: TransactionOnNetwork): resources.SmartContractDeployOutcome;
    awaitCompletedDeploy(txHash: string): Promise<resources.SmartContractDeployOutcome>;
    createTransactionForUpgrade(sender: IAccount, nonce: bigint, options: resources.ContractUpgradeInput & BaseControllerInput): Promise<Transaction>;
    createTransactionForExecute(sender: IAccount, nonce: bigint, options: resources.ContractExecuteInput & BaseControllerInput): Promise<Transaction>;
    parseExecute(transactionOnNetwork: TransactionOnNetwork): resources.ParsedSmartContractCallOutcome;
    awaitCompletedExecute(txHash: string): Promise<resources.ParsedSmartContractCallOutcome>;
    query(options: SmartContractQueryInput): Promise<any[]>;
    runQuery(query: SmartContractQuery): Promise<SmartContractQueryResponse>;
    createQuery(options: SmartContractQueryInput): SmartContractQuery;
    private raiseForStatus;
    parseQueryResponse(response: SmartContractQueryResponse): any[];
    private encodeArguments;
    private areArgsOfTypedValue;
    private areArgsBuffers;
}
