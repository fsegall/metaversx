"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SmartContractTransactionsOutcomeParser = void 0;
const abi_1 = require("../abi");
const address_1 = require("../core/address");
const constants_1 = require("../core/constants");
const errors_1 = require("../core/errors");
const resources_1 = require("../transactionsOutcomeParsers/resources");
var Events;
(function (Events) {
    Events["SCDeploy"] = "SCDeploy";
    Events["SignalError"] = "signalError";
    Events["WriteLog"] = "writeLog";
})(Events || (Events = {}));
class SmartContractTransactionsOutcomeParser {
    constructor(options) {
        this.abi = options?.abi;
    }
    /**
     * Parses the transaction and recovers basic information about the contract(s) deployed by the transaction.
     * @param options
     */
    parseDeploy(options) {
        return this.parseDeployGivenTransactionOnNetwork(options.transactionOnNetwork);
    }
    parseDeployGivenTransactionOnNetwork(transactionOnNetwork) {
        const directCallOutcome = this.findDirectSmartContractCallOutcome(transactionOnNetwork);
        const events = transactionOnNetwork.logs.events
            .concat(transactionOnNetwork.smartContractResults.flatMap((result) => result.logs.events))
            .filter((event) => event.identifier === Events.SCDeploy);
        const contracts = events.map((event) => this.parseScDeployEvent({
            topics: event.topics.map((topic) => Buffer.from(topic)),
        }));
        return {
            returnCode: directCallOutcome.returnCode,
            returnMessage: directCallOutcome.returnMessage,
            contracts: contracts,
        };
    }
    parseScDeployEvent(event) {
        const topicForAddress = Buffer.from(event.topics[0]).toString("hex");
        const topicForOwnerAddress = Buffer.from(event.topics[1]).toString("hex");
        const topicForCodeHash = Buffer.from(event.topics[2]);
        const address = topicForAddress?.length ? new address_1.Address(topicForAddress) : address_1.Address.empty();
        const ownerAddress = topicForOwnerAddress?.length ? new address_1.Address(topicForOwnerAddress) : address_1.Address.empty();
        const codeHash = topicForCodeHash;
        return {
            address,
            ownerAddress,
            codeHash,
        };
    }
    parseExecute(options) {
        return this.parseExecuteGivenTransactionOnNetwork(options.transactionOnNetwork, options.function);
    }
    parseExecuteGivenTransactionOnNetwork(transactionOnNetwork, functionName) {
        const directCallOutcome = this.findDirectSmartContractCallOutcome(transactionOnNetwork);
        if (!this.abi) {
            return {
                values: directCallOutcome.returnDataParts,
                returnCode: directCallOutcome.returnCode,
                returnMessage: directCallOutcome.returnMessage,
            };
        }
        functionName = functionName || directCallOutcome.function;
        if (!functionName) {
            throw new errors_1.Err(`Function name is not available in the transaction, thus endpoint definition (ABI) cannot be picked (for parsing). Maybe provide the "function" parameter explicitly?`);
        }
        const argsSerializer = new abi_1.ArgSerializer();
        const endpoint = this.abi.getEndpoint(functionName);
        const buffers = directCallOutcome.returnDataParts.map((part) => Buffer.from(part));
        const values = argsSerializer.buffersToValues(buffers, endpoint.output);
        return {
            returnCode: directCallOutcome.returnCode,
            returnMessage: directCallOutcome.returnMessage,
            values: values.map((value) => value.valueOf()),
        };
    }
    findDirectSmartContractCallOutcome(transactionOnNetwork) {
        let outcome = this.findDirectSmartContractCallOutcomeWithinSmartContractResults(transactionOnNetwork);
        if (outcome) {
            return outcome;
        }
        outcome = this.findDirectSmartContractCallOutcomeIfError(transactionOnNetwork);
        if (outcome) {
            return outcome;
        }
        outcome = this.findDirectSmartContractCallOutcomeWithinWriteLogEvents(transactionOnNetwork);
        if (outcome) {
            return outcome;
        }
        return new resources_1.SmartContractCallOutcome({
            function: transactionOnNetwork.function,
            returnCode: "",
            returnMessage: "",
            returnDataParts: [],
        });
    }
    findDirectSmartContractCallOutcomeWithinSmartContractResults(transactionOnNetwork) {
        const argSerializer = new abi_1.ArgSerializer();
        const eligibleResults = [];
        for (const result of transactionOnNetwork.smartContractResults) {
            const matchesCriteriaOnData = Buffer.from(result.data).toString("utf-8").startsWith(constants_1.ARGUMENTS_SEPARATOR);
            const matchesCriteriaOnReceiver = result.receiver.toBech32() === transactionOnNetwork.sender.toBech32();
            const matchesCriteriaOnPreviousHash = result;
            const matchesCriteria = matchesCriteriaOnData && matchesCriteriaOnReceiver && matchesCriteriaOnPreviousHash;
            if (matchesCriteria) {
                eligibleResults.push(result);
            }
        }
        if (eligibleResults.length === 0) {
            return null;
        }
        if (eligibleResults.length > 1) {
            throw new Error(`More than one smart contract result (holding the return data) found for transaction: ${transactionOnNetwork.hash}`);
        }
        const [result] = eligibleResults;
        const [_ignored, returnCode, ...returnDataParts] = argSerializer.stringToBuffers(result.data.toString());
        return new resources_1.SmartContractCallOutcome({
            function: transactionOnNetwork.function,
            returnCode: returnCode?.toString(),
            returnMessage: result.raw["returnMessage"] || returnCode?.toString(),
            returnDataParts: returnDataParts,
        });
    }
    findDirectSmartContractCallOutcomeIfError(transactionOnNetwork) {
        const argSerializer = new abi_1.ArgSerializer();
        const eventIdentifier = Events.SignalError;
        const eligibleEvents = [];
        // First, look in "logs":
        eligibleEvents.push(...transactionOnNetwork.logs.events.filter((event) => event.identifier === eventIdentifier));
        // Then, look in "logs" of "contractResults":
        for (const result of transactionOnNetwork.smartContractResults) {
            if (result.raw["prevTxHash"] != transactionOnNetwork.hash) {
                continue;
            }
            eligibleEvents.push(...result.logs.events.filter((event) => event.identifier === eventIdentifier));
        }
        if (eligibleEvents.length === 0) {
            return null;
        }
        if (eligibleEvents.length > 1) {
            throw new Error(`More than one "${eventIdentifier}" event found for transaction: ${transactionOnNetwork.hash}`);
        }
        const [event] = eligibleEvents;
        const data = Buffer.from(event.data).toString();
        const lastTopic = event.topics[event.topics.length - 1]?.toString();
        const parts = argSerializer.stringToBuffers(data);
        // Assumption: the last part is the return code.
        const returnCode = parts[parts.length - 1];
        return new resources_1.SmartContractCallOutcome({
            function: transactionOnNetwork.function,
            returnCode: returnCode?.toString() || eventIdentifier,
            returnMessage: lastTopic || returnCode?.toString() || eventIdentifier,
            returnDataParts: [],
        });
    }
    findDirectSmartContractCallOutcomeWithinWriteLogEvents(transactionOnNetwork) {
        const argSerializer = new abi_1.ArgSerializer();
        const eventIdentifier = Events.WriteLog;
        const eligibleEvents = [];
        // First, look in "logs":
        eligibleEvents.push(...transactionOnNetwork.logs.events.filter((event) => event.identifier === eventIdentifier));
        // Then, look in "logs" of "contractResults":
        for (const result of transactionOnNetwork.smartContractResults) {
            if (result.raw["prevTxHash"] != transactionOnNetwork.hash) {
                continue;
            }
            eligibleEvents.push(...result.logs.events.filter((event) => event.identifier === eventIdentifier));
        }
        if (eligibleEvents.length === 0) {
            return null;
        }
        if (eligibleEvents.length > 1) {
            throw new Error(`More than one "${eventIdentifier}" event found for transaction: ${transactionOnNetwork.hash}`);
        }
        const [event] = eligibleEvents;
        const data = Buffer.from(event.data).toString();
        const [_ignored, returnCode, ...returnDataParts] = argSerializer.stringToBuffers(data);
        return new resources_1.SmartContractCallOutcome({
            function: transactionOnNetwork.function,
            returnCode: returnCode?.toString(),
            returnMessage: returnCode?.toString(),
            returnDataParts: returnDataParts,
        });
    }
}
exports.SmartContractTransactionsOutcomeParser = SmartContractTransactionsOutcomeParser;
//# sourceMappingURL=smartContractTransactionsOutcomeParser.js.map