"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransferTransactionsFactory = void 0;
const constants_1 = require("../core/constants");
const errors_1 = require("../core/errors");
const tokens_1 = require("../core/tokens");
const tokenTransfersDataBuilder_1 = require("../core/tokenTransfersDataBuilder");
const transaction_1 = require("../core/transaction");
const transactionBuilder_1 = require("../core/transactionBuilder");
const ADDITIONAL_GAS_FOR_ESDT_TRANSFER = 100000;
const ADDITIONAL_GAS_FOR_ESDT_NFT_TRANSFER = 800000;
/**
 * Use this class to create transactions for native token transfers (EGLD) or custom tokens transfers (ESDT/NTF/MetaESDT).
 */
class TransferTransactionsFactory {
    constructor(options) {
        this.config = options.config;
        this.tokenComputer = new tokens_1.TokenComputer();
        this.tokenTransfersDataBuilder = new tokenTransfersDataBuilder_1.TokenTransfersDataBuilder();
    }
    createTransactionForNativeTokenTransfer(sender, options) {
        const data = options.data || new Uint8Array();
        return new transaction_1.Transaction({
            sender: sender,
            receiver: options.receiver,
            chainID: this.config.chainID,
            gasLimit: this.computeGasForMoveBalance(this.config, data),
            data: data,
            value: options.nativeAmount ?? BigInt(0),
        });
    }
    createTransactionForESDTTokenTransfer(sender, options) {
        const numberOfTransfers = options.tokenTransfers.length;
        if (numberOfTransfers === 0) {
            throw new errors_1.ErrBadUsage("No token transfer has been provided");
        }
        if (numberOfTransfers === 1) {
            return this.createSingleESDTTransferTransaction(sender, options);
        }
        const { dataParts, extraGasForTransfer } = this.buildMultiESDTNFTTransferData(options.tokenTransfers, options.receiver);
        return new transactionBuilder_1.TransactionBuilder({
            config: this.config,
            sender: sender,
            receiver: sender,
            dataParts: dataParts,
            gasLimit: extraGasForTransfer,
            addDataMovementGas: true,
        }).build();
    }
    createTransactionForTransfer(sender, options) {
        const nativeAmount = options.nativeAmount ?? 0n;
        let tokenTransfers = options.tokenTransfers ? [...options.tokenTransfers] : [];
        const numberOfTokens = tokenTransfers.length;
        if (numberOfTokens && options.data?.length) {
            throw new errors_1.ErrBadUsage("Can't set data field when sending esdt tokens");
        }
        if ((nativeAmount && numberOfTokens === 0) || options.data) {
            return this.createTransactionForNativeTokenTransfer(sender, {
                receiver: options.receiver,
                nativeAmount: nativeAmount,
                data: options.data,
            });
        }
        const nativeTransfer = nativeAmount ? tokens_1.TokenTransfer.newFromNativeAmount(nativeAmount) : undefined;
        if (nativeTransfer) {
            tokenTransfers.push(nativeTransfer);
        }
        return this.createTransactionForESDTTokenTransfer(sender, {
            receiver: options.receiver,
            tokenTransfers: tokenTransfers,
        });
    }
    createSingleESDTTransferTransaction(sender, options) {
        const transfer = options.tokenTransfers[0];
        const { dataParts, extraGasForTransfer, receiver } = this.buildTransferData(transfer, {
            sender,
            receiver: options.receiver,
        });
        return new transactionBuilder_1.TransactionBuilder({
            config: this.config,
            sender: sender,
            receiver: receiver,
            dataParts: dataParts,
            gasLimit: extraGasForTransfer,
            addDataMovementGas: true,
        }).build();
    }
    buildTransferData(transfer, options) {
        let dataParts = [];
        let extraGasForTransfer;
        let receiver = options.receiver;
        if (this.tokenComputer.isFungible(transfer.token)) {
            if (transfer.token.identifier === constants_1.EGLD_IDENTIFIER_FOR_MULTI_ESDTNFT_TRANSFER) {
                ({ dataParts, extraGasForTransfer } = this.buildMultiESDTNFTTransferData([transfer], receiver));
                receiver = options.sender;
            }
            else {
                ({ dataParts, extraGasForTransfer } = this.buildESDTTransferData(transfer));
            }
        }
        else {
            ({ dataParts, extraGasForTransfer } = this.buildSingleESDTNFTTransferData(transfer, receiver));
            receiver = options.sender; // Override receiver for non-fungible tokens
        }
        return { dataParts, extraGasForTransfer, receiver };
    }
    buildMultiESDTNFTTransferData(transfer, receiver) {
        return {
            dataParts: this.tokenTransfersDataBuilder.buildDataPartsForMultiESDTNFTTransfer(receiver, transfer),
            extraGasForTransfer: this.config.gasLimitMultiESDTNFTTransfer * BigInt(transfer.length) +
                BigInt(ADDITIONAL_GAS_FOR_ESDT_NFT_TRANSFER),
        };
    }
    buildESDTTransferData(transfer) {
        return {
            dataParts: this.tokenTransfersDataBuilder.buildDataPartsForESDTTransfer(transfer),
            extraGasForTransfer: this.config.gasLimitESDTTransfer + BigInt(ADDITIONAL_GAS_FOR_ESDT_TRANSFER),
        };
    }
    buildSingleESDTNFTTransferData(transfer, receiver) {
        return {
            dataParts: this.tokenTransfersDataBuilder.buildDataPartsForSingleESDTNFTTransfer(transfer, receiver),
            extraGasForTransfer: this.config.gasLimitESDTNFTTransfer + BigInt(ADDITIONAL_GAS_FOR_ESDT_NFT_TRANSFER),
        };
    }
    computeGasForMoveBalance(config, data) {
        return config.minGasLimit + config.gasLimitPerByte * BigInt(data.length);
    }
}
exports.TransferTransactionsFactory = TransferTransactionsFactory;
//# sourceMappingURL=transferTransactionsFactory.js.map