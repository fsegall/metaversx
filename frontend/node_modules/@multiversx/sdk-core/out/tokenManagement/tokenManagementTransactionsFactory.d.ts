import { Address } from "../core/address";
import { Transaction } from "../core/transaction";
import * as resources from "./resources";
interface IConfig {
    chainID: string;
    addressHrp: string;
    minGasLimit: bigint;
    gasLimitPerByte: bigint;
    gasLimitIssue: bigint;
    gasLimitToggleBurnRoleGlobally: bigint;
    gasLimitEsdtLocalMint: bigint;
    gasLimitEsdtLocalBurn: bigint;
    gasLimitSetSpecialRole: bigint;
    gasLimitPausing: bigint;
    gasLimitFreezing: bigint;
    gasLimitWiping: bigint;
    gasLimitEsdtNftCreate: bigint;
    gasLimitEsdtNftUpdateAttributes: bigint;
    gasLimitEsdtNftAddQuantity: bigint;
    gasLimitEsdtNftBurn: bigint;
    gasLimitStorePerByte: bigint;
    gasLimitEsdtModifyRoyalties: bigint;
    gasLimitEsdtModifyCreator: bigint;
    gasLimitEsdtMetadataUpdate: bigint;
    gasLimitSetNewUris: bigint;
    gasLimitNftMetadataRecreate: bigint;
    gasLimitNftChangeToDynamic: bigint;
    gasLimitUpdateTokenId: bigint;
    gasLimitRegisterDynamic: bigint;
    issueCost: bigint;
}
/**
 * Use this class to create token management transactions like issuing ESDTs, creating NFTs, setting roles, etc.
 */
export declare class TokenManagementTransactionsFactory {
    private readonly config;
    private readonly argSerializer;
    private readonly trueAsString;
    private readonly falseAsString;
    private readonly esdtContractAddress;
    constructor(options: {
        config: IConfig;
    });
    createTransactionForIssuingFungible(sender: Address, options: resources.IssueFungibleInput): Transaction;
    createTransactionForIssuingSemiFungible(sender: Address, options: resources.IssueSemiFungibleInput): Transaction;
    createTransactionForIssuingNonFungible(sender: Address, options: resources.IssueNonFungibleInput): Transaction;
    createTransactionForRegisteringMetaESDT(sender: Address, options: resources.RegisterMetaESDTInput): Transaction;
    createTransactionForRegisteringAndSettingRoles(sender: Address, options: resources.RegisterRolesInput): Transaction;
    createTransactionForSettingBurnRoleGlobally(sender: Address, options: resources.BurnRoleGloballyInput): Transaction;
    createTransactionForUnsettingBurnRoleGlobally(sender: Address, options: resources.BurnRoleGloballyInput): Transaction;
    createTransactionForSettingSpecialRoleOnFungibleToken(sender: Address, options: resources.FungibleSpecialRoleInput): Transaction;
    createTransactionForUnsettingSpecialRoleOnFungibleToken(sender: Address, options: resources.UnsetFungibleSpecialRoleInput): Transaction;
    createTransactionForSettingSpecialRoleOnSemiFungibleToken(sender: Address, options: resources.SemiFungibleSpecialRoleInput): Transaction;
    createTransactionForUnsettingSpecialRoleOnSemiFungibleToken(sender: Address, options: resources.UnsetSemiFungibleSpecialRoleInput): Transaction;
    createTransactionForSettingSpecialRoleOnMetaESDT(sender: Address, options: resources.SemiFungibleSpecialRoleInput): Transaction;
    createTransactionForUnsettingSpecialRoleOnMetaESDT(sender: Address, options: resources.UnsetSemiFungibleSpecialRoleInput): Transaction;
    createTransactionForSettingSpecialRoleOnNonFungibleToken(sender: Address, options: resources.SpecialRoleInput): Transaction;
    createTransactionForUnsettingSpecialRoleOnNonFungibleToken(sender: Address, options: resources.UnsetSpecialRoleInput): Transaction;
    createTransactionForCreatingNFT(sender: Address, options: resources.MintInput): Transaction;
    createTransactionForPausing(sender: Address, options: resources.PausingInput): Transaction;
    createTransactionForUnpausing(sender: Address, options: resources.PausingInput): Transaction;
    createTransactionForFreezing(sender: Address, options: resources.ManagementInput): Transaction;
    createTransactionForUnfreezing(sender: Address, options: resources.ManagementInput): Transaction;
    createTransactionForWiping(sender: Address, options: resources.ManagementInput): Transaction;
    createTransactionForLocalMint(sender: Address, options: resources.LocalMintInput): Transaction;
    createTransactionForLocalBurning(sender: Address, options: resources.LocalBurnInput): Transaction;
    createTransactionForUpdatingAttributes(sender: Address, options: resources.UpdateAttributesInput): Transaction;
    createTransactionForAddingQuantity(sender: Address, options: resources.UpdateQuantityInput): Transaction;
    createTransactionForBurningQuantity(sender: Address, options: resources.UpdateQuantityInput): Transaction;
    createTransactionForModifyingRoyalties(sender: Address, options: resources.ModifyRoyaltiesInput): Transaction;
    createTransactionForSettingNewUris(sender: Address, options: resources.SetNewUriInput): Transaction;
    createTransactionForModifyingCreator(sender: Address, options: resources.ModifyCreatorInput): Transaction;
    createTransactionForUpdatingMetadata(sender: Address, options: resources.ManageMetadataInput): Transaction;
    createTransactionForMetadataRecreate(sender: Address, options: resources.ManageMetadataInput): Transaction;
    createTransactionForChangingTokenToDynamic(sender: Address, options: resources.ChangeTokenToDynamicInput): Transaction;
    createTransactionForUpdatingTokenId(sender: Address, options: resources.UpdateTokenIDInput): Transaction;
    createTransactionForRegisteringDynamicToken(sender: Address, options: resources.RegisteringDynamicTokenInput): Transaction;
    createTransactionForRegisteringDynamicAndSettingRoles(sender: Address, options: resources.RegisteringDynamicTokenInput): Transaction;
    private notifyAboutUnsettingBurnRoleGlobally;
    private boolToString;
}
export {};
