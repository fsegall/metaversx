"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenManagementTransactionsOutcomeParser = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const utils_1 = require("../abi/codec/utils");
const address_1 = require("../core/address");
const errors_1 = require("../core/errors");
const resources_1 = require("../transactionsOutcomeParsers/resources");
class TokenManagementTransactionsOutcomeParser {
    constructor() { }
    parseIssueFungible(transaction) {
        this.ensureNoError(transaction.logs.events);
        const events = resources_1.findEventsByIdentifier(transaction, "issue");
        return events.map((event) => ({ tokenIdentifier: this.extractTokenIdentifier(event) }));
    }
    parseIssueNonFungible(transaction) {
        this.ensureNoError(transaction.logs.events);
        const events = resources_1.findEventsByIdentifier(transaction, "issueNonFungible");
        return events.map((event) => ({ tokenIdentifier: this.extractTokenIdentifier(event) }));
    }
    parseIssueSemiFungible(transaction) {
        this.ensureNoError(transaction.logs.events);
        const events = resources_1.findEventsByIdentifier(transaction, "issueSemiFungible");
        return events.map((event) => ({ tokenIdentifier: this.extractTokenIdentifier(event) }));
    }
    parseRegisterMetaEsdt(transaction) {
        this.ensureNoError(transaction.logs.events);
        const events = resources_1.findEventsByIdentifier(transaction, "registerMetaESDT");
        return events.map((event) => ({ tokenIdentifier: this.extractTokenIdentifier(event) }));
    }
    parseRegisterAndSetAllRoles(transaction) {
        this.ensureNoError(transaction.logs.events);
        const registerEvents = resources_1.findEventsByIdentifier(transaction, "registerAndSetAllRoles");
        const setRoleEvents = resources_1.findEventsByIdentifier(transaction, "ESDTSetRole");
        if (registerEvents.length !== setRoleEvents.length) {
            throw new errors_1.ErrParseTransactionOutcome("Register Events and Set Role events mismatch. Should have the same number of events.");
        }
        return registerEvents.map((registerEvent, index) => {
            const tokenIdentifier = this.extractTokenIdentifier(registerEvent);
            const encodedRoles = setRoleEvents[index].topics.slice(3);
            const roles = encodedRoles.map((role) => this.decodeTopicAsString(role));
            return { tokenIdentifier, roles };
        });
    }
    parseSetBurnRoleGlobally(transaction) {
        this.ensureNoError(transaction.logs.events);
    }
    parseUnsetBurnRoleGlobally(transaction) {
        this.ensureNoError(transaction.logs.events);
    }
    parseSetSpecialRole(transaction) {
        this.ensureNoError(transaction.logs.events);
        const events = resources_1.findEventsByIdentifier(transaction, "ESDTSetRole");
        return events.map((event) => this.getOutputForSetSpecialRoleEvent(event));
    }
    getOutputForSetSpecialRoleEvent(event) {
        const userAddress = event.address;
        const tokenIdentifier = this.extractTokenIdentifier(event);
        const encodedRoles = event.topics.slice(3);
        const roles = encodedRoles.map((role) => this.decodeTopicAsString(role));
        return { userAddress: userAddress, tokenIdentifier: tokenIdentifier, roles: roles };
    }
    parseNftCreate(transaction) {
        this.ensureNoError(transaction.logs.events);
        const events = resources_1.findEventsByIdentifier(transaction, "ESDTNFTCreate");
        return events.map((event) => this.getOutputForNftCreateEvent(event));
    }
    getOutputForNftCreateEvent(event) {
        const tokenIdentifier = this.extractTokenIdentifier(event);
        const nonce = this.extractNonce(event);
        const amount = this.extractAmount(event);
        return { tokenIdentifier: tokenIdentifier, nonce: nonce, initialQuantity: amount };
    }
    parseLocalMint(transaction) {
        this.ensureNoError(transaction.logs.events);
        const events = resources_1.findEventsByIdentifier(transaction, "ESDTLocalMint");
        return events.map((event) => this.getOutputForLocalMintEvent(event));
    }
    getOutputForLocalMintEvent(event) {
        const userAddress = event.address;
        const tokenIdentifier = this.extractTokenIdentifier(event);
        const nonce = this.extractNonce(event);
        const mintedSupply = this.extractAmount(event);
        return {
            userAddress: userAddress,
            tokenIdentifier: tokenIdentifier,
            nonce: nonce,
            mintedSupply: mintedSupply,
        };
    }
    parseLocalBurn(transaction) {
        this.ensureNoError(transaction.logs.events);
        const events = resources_1.findEventsByIdentifier(transaction, "ESDTLocalBurn");
        return events.map((event) => this.getOutputForLocalBurnEvent(event));
    }
    getOutputForLocalBurnEvent(event) {
        const userAddress = event.address;
        const tokenIdentifier = this.extractTokenIdentifier(event);
        const nonce = this.extractNonce(event);
        const burntSupply = this.extractAmount(event);
        return {
            userAddress: userAddress,
            tokenIdentifier: tokenIdentifier,
            nonce: nonce,
            burntSupply: burntSupply,
        };
    }
    parsePause(transaction) {
        this.ensureNoError(transaction.logs.events);
        const events = resources_1.findEventsByIdentifier(transaction, "ESDTPause");
        return events.map((event) => ({ tokenIdentifier: this.extractTokenIdentifier(event) }));
    }
    parseUnpause(transaction) {
        this.ensureNoError(transaction.logs.events);
        const events = resources_1.findEventsByIdentifier(transaction, "ESDTUnPause");
        return events.map((event) => ({ tokenIdentifier: this.extractTokenIdentifier(event) }));
    }
    parseFreeze(transaction) {
        this.ensureNoError(transaction.logs.events);
        const events = resources_1.findEventsByIdentifier(transaction, "ESDTFreeze");
        return events.map((event) => this.getOutputForFreezeEvent(event));
    }
    getOutputForFreezeEvent(event) {
        const userAddress = this.extractAddress(event);
        const tokenIdentifier = this.extractTokenIdentifier(event);
        const nonce = this.extractNonce(event);
        const balance = this.extractAmount(event);
        return {
            userAddress: userAddress,
            tokenIdentifier: tokenIdentifier,
            nonce: nonce,
            balance: balance,
        };
    }
    parseUnfreeze(transaction) {
        this.ensureNoError(transaction.logs.events);
        const events = resources_1.findEventsByIdentifier(transaction, "ESDTUnFreeze");
        return events.map((event) => this.getOutputForUnfreezeEvent(event));
    }
    getOutputForUnfreezeEvent(event) {
        const userAddress = this.extractAddress(event);
        const tokenIdentifier = this.extractTokenIdentifier(event);
        const nonce = this.extractNonce(event);
        const balance = this.extractAmount(event);
        return {
            userAddress: userAddress,
            tokenIdentifier: tokenIdentifier,
            nonce: nonce,
            balance: balance,
        };
    }
    parseWipe(transaction) {
        this.ensureNoError(transaction.logs.events);
        const events = resources_1.findEventsByIdentifier(transaction, "ESDTWipe");
        return events.map((event) => this.getOutputForWipeEvent(event));
    }
    getOutputForWipeEvent(event) {
        const userAddress = this.extractAddress(event);
        const tokenIdentifier = this.extractTokenIdentifier(event);
        const nonce = this.extractNonce(event);
        const balance = this.extractAmount(event);
        return {
            userAddress: userAddress,
            tokenIdentifier: tokenIdentifier,
            nonce: nonce,
            balance: balance,
        };
    }
    parseUpdateAttributes(transaction) {
        this.ensureNoError(transaction.logs.events);
        const events = resources_1.findEventsByIdentifier(transaction, "ESDTNFTUpdateAttributes");
        return events.map((event) => this.getOutputForUpdateAttributesEvent(event));
    }
    getOutputForUpdateAttributesEvent(event) {
        const tokenIdentifier = this.extractTokenIdentifier(event);
        const nonce = this.extractNonce(event);
        const attributes = event.topics[3] ? event.topics[3] : Buffer.from("");
        return {
            tokenIdentifier: tokenIdentifier,
            nonce: nonce,
            attributes: attributes,
        };
    }
    parseAddQuantity(transaction) {
        this.ensureNoError(transaction.logs.events);
        const events = resources_1.findEventsByIdentifier(transaction, "ESDTNFTAddQuantity");
        return events.map((event) => this.getOutputForAddQuantityEvent(event));
    }
    getOutputForAddQuantityEvent(event) {
        const tokenIdentifier = this.extractTokenIdentifier(event);
        const nonce = this.extractNonce(event);
        const addedQuantity = this.extractAmount(event);
        return {
            tokenIdentifier: tokenIdentifier,
            nonce: nonce,
            addedQuantity: addedQuantity,
        };
    }
    parseBurnQuantity(transaction) {
        this.ensureNoError(transaction.logs.events);
        const events = resources_1.findEventsByIdentifier(transaction, "ESDTNFTBurn");
        return events.map((event) => this.getOutputForBurnQuantityEvent(event));
    }
    getOutputForBurnQuantityEvent(event) {
        const tokenIdentifier = this.extractTokenIdentifier(event);
        const nonce = this.extractNonce(event);
        const burntQuantity = this.extractAmount(event);
        return {
            tokenIdentifier: tokenIdentifier,
            nonce: nonce,
            burntQuantity: burntQuantity,
        };
    }
    parseModifyRoyalties(transaction) {
        this.ensureNoError(transaction.logs.events);
        const events = resources_1.findEventsByIdentifier(transaction, "ESDTModifyRoyalties");
        return events.map((event) => this.getOutputForESDTModifyRoyaltiesEvent(event));
    }
    getOutputForESDTModifyRoyaltiesEvent(event) {
        const tokenIdentifier = this.extractTokenIdentifier(event);
        const nonce = this.extractNonce(event);
        const royalties = !event.topics[3]?.length
            ? BigInt(0)
            : BigInt(new bignumber_js_1.default(Buffer.from(event.topics[3]).toString("hex"), 16).toFixed());
        return {
            tokenIdentifier: tokenIdentifier,
            nonce: nonce,
            royalties,
        };
    }
    parseSetNewUris(transaction) {
        this.ensureNoError(transaction.logs.events);
        const events = resources_1.findEventsByIdentifier(transaction, "ESDTSetNewURIs");
        return events.map((event) => this.getOutputForESDTSetNewURIsEvent(event));
    }
    getOutputForESDTSetNewURIsEvent(event) {
        const tokenIdentifier = this.extractTokenIdentifier(event);
        const nonce = this.extractNonce(event);
        const uri = event.topics[3]?.length ? event.topics[3].toString() : "";
        return { tokenIdentifier, nonce, uri };
    }
    parseModifyCreator(transaction) {
        this.ensureNoError(transaction.logs.events);
        const events = resources_1.findEventsByIdentifier(transaction, "ESDTModifyCreator");
        return events.map((event) => this.getOutputForESDTModifyCreatorEvent(event));
    }
    getOutputForESDTModifyCreatorEvent(event) {
        const tokenIdentifier = this.extractTokenIdentifier(event);
        const nonce = this.extractNonce(event);
        return { tokenIdentifier, nonce };
    }
    parseUpdateMetadata(transaction) {
        this.ensureNoError(transaction.logs.events);
        const events = resources_1.findEventsByIdentifier(transaction, "ESDTMetaDataUpdate");
        return events.map((event) => this.getOutputForESDTUpdateMetadataEvent(event));
    }
    getOutputForESDTUpdateMetadataEvent(event) {
        const tokenIdentifier = this.extractTokenIdentifier(event);
        const nonce = this.extractNonce(event);
        const metadata = event.topics[3]?.length ? new Uint8Array(Buffer.from(event.topics[3])) : new Uint8Array();
        return { tokenIdentifier, nonce, metadata };
    }
    parseMetadataRecreate(transaction) {
        this.ensureNoError(transaction.logs.events);
        const events = resources_1.findEventsByIdentifier(transaction, "ESDTMetaDataRecreate");
        return events.map((event) => this.getOutputForESDTMetadataRecreateEvent(event));
    }
    getOutputForESDTMetadataRecreateEvent(event) {
        const tokenIdentifier = this.extractTokenIdentifier(event);
        const nonce = this.extractNonce(event);
        const metadata = event.topics[3]?.length ? new Uint8Array(Buffer.from(event.topics[3])) : new Uint8Array();
        return { tokenIdentifier, nonce, metadata };
    }
    parseChangeTokenToDynamic(transaction) {
        this.ensureNoError(transaction.logs.events);
        const events = resources_1.findEventsByIdentifier(transaction, "changeToDynamic");
        return events.map((event) => this.getOutputForChangeToDynamicEvent(event));
    }
    getOutputForChangeToDynamicEvent(event) {
        const tokenIdentifier = this.extractTokenIdentifier(event);
        const tokenName = event.topics[1]?.length ? event.topics[1].toString() : "";
        const tickerName = event.topics[2]?.length ? event.topics[2].toString() : "";
        const tokenType = event.topics[3]?.length ? event.topics[3].toString() : "";
        return { tokenIdentifier, tokenName, tickerName, tokenType };
    }
    parseRegisterDynamicToken(transaction) {
        this.ensureNoError(transaction.logs.events);
        const events = resources_1.findEventsByIdentifier(transaction, "registerDynamic");
        return events.map((event) => this.getOutputForRegisterDynamicToken(event));
    }
    getOutputForRegisterDynamicToken(event) {
        const tokenIdentifier = event.topics[0]?.length ? event.topics[0].toString() : "";
        const tokenName = event.topics[1]?.length ? event.topics[1].toString() : "";
        const tokenTicker = event.topics[2]?.length ? event.topics[2].toString() : "";
        const tokenType = event.topics[3]?.length ? event.topics[3].toString() : "";
        const numOfDecimals = event.topics[4]?.length ? Number(Buffer.from(event.topics[4]).toString()) : 0;
        return { tokenIdentifier, tokenName, tokenTicker, tokenType, numOfDecimals };
    }
    parseRegisterDynamicTokenAndSettingRoles(transaction) {
        this.ensureNoError(transaction.logs.events);
        const events = resources_1.findEventsByIdentifier(transaction, "registerAndSetAllRolesDynamic");
        return events.map((event) => this.getOutputForRegisterDynamicTokenAndSettingRoles(event));
    }
    getOutputForRegisterDynamicTokenAndSettingRoles(event) {
        const tokenIdentifier = event.topics[0]?.length ? event.topics[0].toString() : "";
        const tokenName = event.topics[1]?.length ? event.topics[1].toString() : "";
        const tokenTicker = event.topics[2]?.length ? event.topics[2].toString() : "";
        const tokenType = event.topics[3]?.length ? event.topics[3].toString() : "";
        const numOfDecimals = event.topics[4]?.length ? Number(Buffer.from(event.topics[4]).toString()) : 0;
        return { tokenIdentifier, tokenName, tokenTicker, tokenType, numOfDecimals };
    }
    ensureNoError(transactionEvents) {
        for (const event of transactionEvents) {
            if (event.identifier == "signalError") {
                const data = Buffer.from(event.additionalData[0]?.toString().slice(1)).toString() || "";
                const message = this.decodeTopicAsString(event.topics[1]);
                throw new errors_1.ErrParseTransactionOutcome(`encountered signalError: ${message} (${Buffer.from(data, "hex").toString()})`);
            }
        }
    }
    extractTokenIdentifier(event) {
        if (!event.topics[0]?.length) {
            return "";
        }
        return event.topics[0].toString();
    }
    extractNonce(event) {
        if (!event.topics[1]?.length) {
            return BigInt(0);
        }
        const nonce = Buffer.from(event.topics[1]);
        return BigInt(utils_1.bufferToBigInt(nonce).toFixed(0));
    }
    extractAmount(event) {
        if (!event.topics[2]?.length) {
            return BigInt(0);
        }
        const amount = Buffer.from(event.topics[2]);
        return BigInt(utils_1.bufferToBigInt(amount).toFixed(0));
    }
    extractAddress(event) {
        if (!event.topics[3]?.length) {
            return "";
        }
        const address = Buffer.from(event.topics[3]);
        return new address_1.Address(address).toBech32();
    }
    decodeTopicAsString(topic) {
        return Buffer.from(topic).toString();
    }
}
exports.TokenManagementTransactionsOutcomeParser = TokenManagementTransactionsOutcomeParser;
//# sourceMappingURL=tokenManagementTransactionsOutcomeParser.js.map