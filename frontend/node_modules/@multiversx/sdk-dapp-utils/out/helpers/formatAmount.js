"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatAmount = void 0;
const sdk_core_1 = require("@multiversx/sdk-core");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const pipe_1 = require("./pipe");
const constants_1 = require("../constants");
const stringIsInteger_1 = require("./stringIsInteger");
function formatAmount({ addCommas = false, decimals = constants_1.DECIMALS, digits = constants_1.DIGITS, input, showIsLessThanDecimalsLabel = false, showLastNonZeroDecimal = true }) {
    if (!(0, stringIsInteger_1.stringIsInteger)(input, false)) {
        throw new Error('Invalid input');
    }
    const LocalBigNumber = bignumber_js_1.default.clone();
    LocalBigNumber.config({ ROUNDING_MODE: bignumber_js_1.default.ROUND_FLOOR });
    const isNegative = LocalBigNumber(input).isNegative();
    let modInput = input;
    if (isNegative) {
        // remove - at start of input
        modInput = input.substring(1);
    }
    return ((0, pipe_1.pipe)(modInput)
        // format
        .then(() => sdk_core_1.TokenTransfer.fungibleFromBigInteger('', modInput, decimals)
        .amountAsBigInteger.shiftedBy(-decimals)
        .toFixed(decimals))
        // format
        .then((current) => {
        const bnBalance = LocalBigNumber(current);
        if (bnBalance.isZero()) {
            return constants_1.ZERO;
        }
        const balance = bnBalance.toString(10);
        const [integerPart, decimalPart] = balance.split('.');
        const bNdecimalPart = LocalBigNumber(decimalPart || 0);
        const decimalPlaces = (0, pipe_1.pipe)(0)
            .if(Boolean(decimalPart && showLastNonZeroDecimal))
            .then(() => Math.max(decimalPart.length, digits))
            .if(bNdecimalPart.isZero() && !showLastNonZeroDecimal)
            .then(0)
            .if(Boolean(decimalPart && !showLastNonZeroDecimal))
            .then(() => Math.min(decimalPart.length, digits))
            .valueOf();
        const shownDecimalsAreZero = decimalPart &&
            digits >= 1 &&
            digits <= decimalPart.length &&
            bNdecimalPart.isGreaterThan(0) &&
            LocalBigNumber(decimalPart.substring(0, digits)).isZero();
        const formatted = bnBalance.toFormat(decimalPlaces);
        const formattedBalance = (0, pipe_1.pipe)(balance)
            .if(addCommas)
            .then(formatted)
            .if(Boolean(shownDecimalsAreZero))
            .then((current) => {
            const integerPartZero = LocalBigNumber(integerPart).isZero();
            const [numericPart, decimalSide] = current.split('.');
            const zeroPlaceholders = new Array(digits - 1).fill(0);
            const zeros = [...zeroPlaceholders, 0].join('');
            const minAmount = [...zeroPlaceholders, 1].join(''); // 00..1
            if (!integerPartZero) {
                return `${numericPart}.${zeros}`;
            }
            if (showIsLessThanDecimalsLabel) {
                return `<${numericPart}.${minAmount}`;
            }
            if (!showLastNonZeroDecimal) {
                return numericPart;
            }
            return `${numericPart}.${decimalSide}`;
        })
            .if(Boolean(!shownDecimalsAreZero && decimalPart))
            .then((current) => {
            const [numericPart] = current.split('.');
            let decimalSide = decimalPart.substring(0, decimalPlaces);
            if (showLastNonZeroDecimal) {
                const noOfZerosAtEnd = digits - decimalSide.length;
                if (noOfZerosAtEnd > 0) {
                    const zeroPadding = Array(noOfZerosAtEnd).fill(0).join('');
                    decimalSide = `${decimalSide}${zeroPadding}`;
                    return `${numericPart}.${decimalSide}`;
                }
                return `${numericPart}.${decimalSide.substring(0, digits)}`;
            }
            if (!decimalSide) {
                return numericPart;
            }
            return `${numericPart}.${decimalSide}`;
        })
            .valueOf();
        const parts = formattedBalance.split('.');
        const hasNoDecimals = parts.length === 1;
        const isNotZero = formattedBalance !== constants_1.ZERO;
        if (digits > 0 && hasNoDecimals && isNotZero) {
            parts.push(constants_1.ZERO.repeat(digits));
        }
        return parts.join('.');
    })
        .if(isNegative)
        .then((current) => `-${current}`)
        .valueOf());
}
exports.formatAmount = formatAmount;
//# sourceMappingURL=formatAmount.js.map