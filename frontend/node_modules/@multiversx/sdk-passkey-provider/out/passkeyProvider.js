"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PasskeyProvider = void 0;
const sdk_core_1 = require("@multiversx/sdk-core");
const ed = __importStar(require("@noble/ed25519"));
const ed25519_1 = require("@noble/ed25519");
const sha512_1 = require("@noble/hashes/sha512");
const axios_1 = __importDefault(require("axios"));
const constants_1 = require("./constants");
const errors_1 = require("./errors");
const webauthn_prf_1 = require("./lib/webauthn-prf");
// By setting this property, we're telling the library
// which specific SHA-512 implementation to use
// when performing cryptographic operations
// like generating keys and signing data
ed.etc.sha512Sync = sha512_1.sha512;
class PasskeyProvider {
    constructor() {
        this.account = { address: '' };
        this.initialized = false;
        this.keyPair = undefined;
        this.axiosInstance = axios_1.default.create();
        this.config = {
            extrasApiUrl: ''
        };
        if (PasskeyProvider._instance) {
            throw new Error('Error: Instantiation failed: Use PasskeyProvider.getInstance() instead of new.');
        }
        PasskeyProvider._instance = this;
    }
    static getInstance() {
        return PasskeyProvider._instance;
    }
    setAddress(address) {
        this.account.address = address;
        return PasskeyProvider._instance;
    }
    setPasskeyServiceUrl(url) {
        this.config.extrasApiUrl = url;
        return PasskeyProvider._instance;
    }
    async init() {
        this.initialized = true;
        return this.initialized;
    }
    async login(options = {}) {
        try {
            if (!this.initialized) {
                throw new Error('Passkey provider is not initialised, call init() first');
            }
            const { token } = options;
            await this.ensureConnected();
            if (!this.keyPair?.privateKey || !this.keyPair?.publicKey) {
                throw new Error('Could not retrieve key pair.');
            }
            this.account.address = this.keyPair.publicKey;
            if (token) {
                const signedToken = await this.signMessageWithPrivateKey({
                    address: this.account.address,
                    message: `${this.account.address}${token}{}`,
                    privateKey: this.keyPair.privateKey
                });
                if (!signedToken.signature) {
                    throw new Error('Could not sign token');
                }
                this.account.signature = Buffer.from(signedToken.signature).toString('hex');
            }
            this.destroyKeyPair();
            return {
                address: this.account.address,
                signature: this.account.signature
            };
        }
        catch (error) {
            throw error;
        }
    }
    destroyKeyPair() {
        this.keyPair = undefined;
    }
    async signMessageWithPrivateKey({ message, address, privateKey }) {
        const signer = new sdk_core_1.UserSigner(sdk_core_1.UserSecretKey.fromString(privateKey));
        const msg = new sdk_core_1.Message({
            ...(address ? { address: new sdk_core_1.Address(address) } : {}),
            data: Buffer.from(message)
        });
        const messageComputer = new sdk_core_1.MessageComputer();
        const messageToSign = new Uint8Array(messageComputer.computeBytesForSigning(msg));
        const signature = await signer.sign(Buffer.from(messageToSign));
        msg.signature = new Uint8Array(signature);
        return msg;
    }
    // Derive the private key seed using HKDF (Web Crypto API)
    async derivePrivateKeySeed(prfOutput) {
        if (!constants_1.safeWindow) {
            throw new Error('Web Crypto API is not available');
        }
        // Import the PRF output as a CryptoKey
        const keyMaterial = await constants_1.safeWindow.crypto.subtle.importKey('raw', // format of the key material
        prfOutput.buffer, // the key material
        'HKDF', // HMAC-based Key Derivation Function
        false, // non-extractable
        ['deriveBits'] // keyUsages
        );
        //should be hardcoded in order to have deterministic output
        const salt = new Uint8Array([]); // Empty salt
        const info = new TextEncoder().encode('Ed25519 Key Generation');
        const derivedBitsBuffer = await constants_1.safeWindow.crypto.subtle.deriveBits({
            name: 'HKDF',
            hash: 'SHA-256',
            salt: salt.buffer,
            info: info.buffer
        }, keyMaterial, 256 // Length in bits
        );
        return new Uint8Array(derivedBitsBuffer);
    }
    // Generate the Ed25519 key pair
    generateEd25519KeyPair(privateKeySeed) {
        const privateKey = privateKeySeed;
        const publicKey = (0, ed25519_1.getPublicKey)(privateKey);
        return {
            publicKey,
            privateKey
        };
    }
    async getUserKeyPair(prfOutput) {
        const privateKeySeed = await this.derivePrivateKeySeed(prfOutput);
        const { privateKey } = this.generateEd25519KeyPair(privateKeySeed);
        const userSecretKey = new sdk_core_1.UserSecretKey(privateKey);
        const address = userSecretKey.generatePublicKey().toAddress();
        return {
            privateKey: userSecretKey.hex(),
            publicKey: address.bech32()
        };
    }
    async setUserKeyPair(prfOutput) {
        this.keyPair = await this.getUserKeyPair(prfOutput);
    }
    async createAccount({ walletName, token }) {
        if (!this.config.extrasApiUrl) {
            throw new Error('Passkey service URL is not set');
        }
        const { data: { challenge } } = await this.axiosInstance.get(`${this.config.extrasApiUrl}${constants_1.PASSKEY_CHALLENGE_ENDPOINT}`);
        const { registration: { extensionResults }, registrationResponse } = await webauthn_prf_1.client.register(walletName, challenge, {
            authenticatorType: 'extern'
        });
        const keyPairData = await this.getUserKeyPair(extensionResults);
        const { data } = await this.axiosInstance.post(`${this.config.extrasApiUrl}${constants_1.PASSKEY_REGISTER_ENDPOINT}`, {
            registrationResponse: {
                ...registrationResponse,
                clientExtensionResults: {}
            },
            challenge,
            passKeyId: keyPairData?.publicKey
        });
        if (!data.isVerified) {
            throw new Error('Passkey verification failed');
        }
        await this.setUserKeyPair(extensionResults);
        return this.login({ token });
    }
    async ensureConnected() {
        if (this.keyPair?.privateKey || this.keyPair?.publicKey) {
            return;
        }
        if (!this.config.extrasApiUrl) {
            throw new Error('Passkey service URL is not set');
        }
        const { data: { challenge } } = await this.axiosInstance.get(`${this.config.extrasApiUrl}${constants_1.PASSKEY_CHALLENGE_ENDPOINT}`);
        let inputKeyMaterial;
        try {
            const { authentication: { extensionResults }, authenticationResponse } = await webauthn_prf_1.client.authenticate([], challenge, {
                userVerification: 'required',
                authenticatorType: 'extern'
            });
            inputKeyMaterial = extensionResults;
            const keyPairData = await this.getUserKeyPair(inputKeyMaterial);
            const { data } = await this.axiosInstance.post(`${this.config.extrasApiUrl}${constants_1.PASSKEY_AUTHENTICATE_ENDPOINT}`, {
                authenticationResponse: {
                    ...authenticationResponse,
                    clientExtensionResults: {}
                },
                challenge,
                passKeyId: keyPairData?.publicKey
            });
            if (!data.isVerified) {
                throw new Error('Passkey verification failed');
            }
            await this.setUserKeyPair(inputKeyMaterial);
        }
        catch (error) {
            throw new errors_1.AuthenticatorNotSupported();
        }
    }
    async isExistingUser(email) {
        return Boolean(window.localStorage.getItem(email));
    }
    async logout() {
        if (!this.initialized) {
            throw new Error('Passkey provider is not initialised, call init() first');
        }
        try {
            this.disconnect();
        }
        catch (error) {
            console.warn('Passkey origin url is already cleared!', error);
        }
        return true;
    }
    disconnect() {
        this.account = { address: '' };
    }
    async getAddress() {
        if (!this.initialized) {
            throw new Error('Passkey provider is not initialised, call init() first');
        }
        return this.account ? this.account.address : '';
    }
    isInitialized() {
        return this.initialized;
    }
    async isConnected() {
        return Boolean(this.account.address);
    }
    async signTransaction(transaction) {
        await this.ensureConnected();
        const signedTransactions = await this.signTransactions([transaction]);
        if (signedTransactions.length != 1) {
            throw new errors_1.ErrCannotSignSingleTransaction();
        }
        this.destroyKeyPair();
        return signedTransactions[0];
    }
    async signTransactions(transactions) {
        await this.ensureConnected();
        const privateKey = this.keyPair?.privateKey;
        if (!privateKey) {
            throw new Error('Unable to sign transactions');
        }
        try {
            const signer = new sdk_core_1.UserSigner(sdk_core_1.UserSecretKey.fromString(privateKey));
            for (const transaction of transactions) {
                const signature = await signer.sign(transaction.serializeForSigning());
                transaction.applySignature(signature);
            }
            this.destroyKeyPair();
            return transactions;
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        catch (error) {
            this.destroyKeyPair();
            throw new Error(`Transaction canceled: ${error.message}.`);
        }
    }
    async signMessage(message) {
        await this.ensureConnected();
        const privateKey = this.keyPair?.privateKey;
        if (!privateKey) {
            throw new Error('Unable to sign message');
        }
        const signedMessage = await this.signMessageWithPrivateKey({
            message: message.data.toString(),
            address: this.account.address,
            privateKey
        });
        message.signature = signedMessage.signature;
        this.destroyKeyPair();
        return message;
    }
    cancelAction() {
        return true;
    }
}
PasskeyProvider._instance = new PasskeyProvider();
exports.PasskeyProvider = PasskeyProvider;
//# sourceMappingURL=passkeyProvider.js.map